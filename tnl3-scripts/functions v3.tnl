###########################################################################################################################################				
# Complex Function Arguments --Out of date
###########################################################################################################################################
#~
#	Should be distributed over -1 to 1, so base mean should be 0. Quality depends on number of iterations
#randgauss ( iterations, seed, deviation, mean)
#
# 	A midpoint based algorithm with bilinear interpolation
#midpoint( iterations, scale, output_scale, scale_delta, output_delta, randomness_coefficent, x,z )
#
# 	Same algorithm using average of points rather than interpolation
#midpointAvg( iterations, scale, output_scale, scale_delta, output_delta, randomness_coefficent, x,z )
#
# 	Voronoi cells are defined using Euclidean distance -M versions use Manhattan, but other distance metrics are in comments
#
# 	Voronoi algorithm that returns the same random number for every x,z in a cell
#voronoiRand( x,z, scale, randomness_coefficent )
#voronoiRand3D( x,y,z, scale, randomness_coefficent )
#
# 	Voronoi based funcion that returns the weighted combination of the two closest points to x,z added to distance_offset
#voronoiCell( x, z, scale, randomness_coefficent, distance_offset, weight1, weight2, weight3 )
#voronoiCell3D( x, y, z, scale, randomness_coefficent, distance_offset, weight1, weight2 )
#
#	Performs the basis function iteration times, scaling input and output accordingly. 
#fractal( iterations, input-scale, output-scale, input-scale-factor, output-scale-factor, y-offset, basis, x,y,z )
#
#	Wraps input v from min to max in a /\/\ pattern not a /|/| pattern
#ridge( min, max, v )
###########################################################################################################################################
#~~
	
############################################################################################################################################
# Positioning
############################################################################################################################################
#~
#Use to position bedrock walls around area to export
chunksx = 32;
chunksz = 32;
xstart_chunk = 0;
zstart_chunk = 0;
# Use to move major landform features around in export area
# Notable exceptions are ores and caves, neither adjust with this
xstart = 0; #51200;	#positive moves left, negative moves right
zstart = 300; #positive moves down, negative moves up

#~~

#### #### #### #### #### #### #### #### #### #### #### #### #
#### #### #### #### #### #### #### #### #### #### #### #### #
#				World Definition
#### #### #### #### #### #### #### #### #### #### #### #### #
#### #### #### #### #### #### #### #### #### #### #### #### #
#~
# An attempt to use voronoiTiles for generating the valley and steppes masks
# Works to a degree. Main problem is that voronoiCell doesn't always return the same value on the edges
# which is essential for blending to work correctly. 
#### layer(
	#### water,
	#### 1,
	#### (x,z) -> #if(voronoiTiles( x + simplexS( x, 32, z, 512) * 512,z + simplexS( x, 32, z, 512) * 512, 1024, 0.7, 5) > 2, 
				#### 256 - voronoiCell(x + simplexS( x, 32, z, 512) * 512,z + simplexS( x, 32, z, 512) * 512, 1024, 0.7, 0, 1, 0, 0)  * 256#, 
				#### #-1)	
#### ),


world = layered-terrain(

#### layer(
	#### stone,
	#### 150,
	#### (x,z) -> 150 + 
			#### if( voronoiCell(x,z, 256, 0.5, 0, 1, 0, 0) * 6 > 2,
				#### abs(sin(voronoiCell(x,z, 256, 0.5, 0, 1, 0, 0))) * 32 + 
				#### abs(sin(voronoiCell(x,z, 256, 0.5, 0, 1, 0, 0) * 8)) * 16 +
				#### abs(sin(voronoiCell(x,z, 256, 0.5, 0, 1, 0, 0) * 16)) * 8,
				#### abs(voronoiCell(x,z, 256, 0.5, 0, 1, 0, 0) )* 6 
			#### )
#### ),

#### #### #### #### #### #### #### #### #### #### #### #### #
# Valley
#### #### #### #### #### #### #### #### #### #### #### #### #
#~
#### layer(
	#### bedrock,
	#### 0,
	#### (x,z) -> voronoi( x, z, s1, 0.50, 2, 1, 1, 0, _manhattan, _lines)
#### ),

layer(
	stone,
	1,
	(x,z) -> complex_cont(x,z)
),

layersUp(redclay, (x,z) -> 9 + simplexS(x,132,z, 32) * 8, 
		greenclay, (x,z) -> 7  + simplexS(x,678,z, 32) * 8, 
		whiteclay, (x,z) -> 5 + simplexS(x,54,z, 32) * 8, 
		purpleclay, (x,z) -> 8 + simplexS(x,89,z, 32) * 8, 
		(x,z) -> voronoiCell(x,z, 64, 0.5, 0, 64, 0, 0) + 70 + simplexS(x,14,z, 64) * 32, complex_cont ),

layersUp(ltgrayclay, (x,z) -> 9 + simplexS(x,24,z, 32) * 8, 
		brownclay, (x,z) -> 7  + simplexS(x,76,z, 32) * 8, 
		blackclay, (x,z) -> 5 + simplexS(x,98,z, 32) * 8, 
		limeclay, (x,z) -> 8 + simplexS(x,34,z, 32) * 8, 
		(x,z) -> voronoiCell(x,z, 64, 0.5, 0, 64, 0, 0) + 99 + (simplexS(x,89,z, 32) * 8) + (simplexS(x,14,z, 64) * 32), complex_cont ),

layersUp(whiteclay, (x,z) -> 9 + simplexS(x,132,z, 32) * 8, 
		magentaclay, (x,z) -> 7  + simplexS(x,678,z, 32) * 8, 
		grayclay, (x,z) -> 5 + simplexS(x,54,z, 32) * 8, 
		cyanclay, (x,z) -> 8 + simplexS(x,89,z, 32) * 8, 
		(x,z) -> voronoiCell(x,z, 64, 0.5, 0, 64, 0, 0) + 128 + (simplexS(x,89,z, 32) * 8) + simplexS(x,34,z, 32) * 8 + (simplexS(x,14,z, 64) * 32), complex_cont ),
#Similar to Minecraft's caves, needs to be masked with a tiles function like the new ore function
layer(
	(x,y,z) -> if ( abs(simplexS(x,y / 16,z, 64) + simplexS(x,y / 16,z, 32) / 2) ** 2 < 0.0025, air, -1),
	(x,z) -> if ( voronoiTiles( x,z + 625, 32, 0.7, 10 ) > 5, 1, -1),
	(x,z) -> if ( voronoiTiles( x,z + 3245, 32, 0.7, 10 ) > 5, 255, 0 )
),						
#landform_common_ore(ore, alt, s1, s2, s3, is_landform, layer_limit, density)
#### simplex_ore(coal_o, (x,z) -> (68 + simplexS(x,132,z, 128) * 64), 4, 23, 86, is_valley, contintent_limit, 2),
#### simplex_ore(iron_o, (x,z) -> (64 + simplexS(x,32,z, 128) * 64), 234, 23, 74, is_valley, contintent_limit, 3),
#### simplex_ore(redstone_o, (x,z) -> (60 + simplexS(x,72,z, 128) * 64), 668, 23, 65, is_valley, contintent_limit, 4),

#### simplex_ore(coal_o, (x,z) -> (138 + simplexS(x,132,z, 128) * 128), 4, 23, 54, is_valley_mount, contintent_limit, 2),
#### simplex_ore(iron_o, (x,z) -> (104 + simplexS(x,34,z, 128) * 128), 234, 23, 54, is_valley_mount, contintent_limit, 3),
#### simplex_ore(redstone_o, (x,z) -> (128 + simplexS(x,67,z, 128) * 128), 668, 45, 98, is_valley_mount, contintent_limit, 4),

layer(
	cobblestone,
	1,
	(x,z) -> if( is_valley(x,z), if( geology_layer_a(x,z) > complex_cont(x,z) - dirt_depth(x,z), complex_cont(x,z) - dirt_depth(x,z),  geology_layer_a(x,z)), -1)
),
#### simplex_ore(redstone_o, (x,z) -> (33 + simplexS(x,132,z, 128) * 64), 46, 23, 86, is_valley, geology_layer_a, 2),
#### simplex_ore(lapis_o, (x,z) -> (30 + simplexS(x,32,z, 128) * 64), 334, 23, 74, is_valley, geology_layer_a, 3),
#### simplex_ore(iron_o, (x,z) -> (26 + simplexS(x,72,z, 128) * 64), 748, 23, 65, is_valley, geology_layer_a, 2),
layer(
	mossycobble,
	1,
	(x,z) -> if( is_valley(x,z), if(geology_layer_b(x,z) > complex_cont(x,z) - dirt_depth(x,z), complex_cont(x,z) - dirt_depth(x,z),  geology_layer_b(x,z)), -1)
),
#### simplex_ore(gold_o, (x,z) -> (13 + simplexS(x,132,z, 128) * 64), 654, 23, 86, is_valley, geology_layer_b, 3),
#### simplex_ore(emerald_o, (x,z) -> (10 + simplexS(x,32,z, 128) * 64), 157, 23, 74, is_valley, geology_layer_b, 3),
#### simplex_ore(diamond_o, (x,z) -> (6 + simplexS(x,72,z, 128) * 64), 3189, 23, 65, is_valley, geology_layer_b, 6),
#~~
#### #### #### #### #### #### #### #### #### #### #### #### #
# Hills 
#### #### #### #### #### #### #### #### #### #### #### #### #
#~
layer(
	sandstone,
	1,
	(x,z) -> if( is_hills(x,z), complex_cont(x,z) - dirt_depth(x,z), -1)
),
#Taper off 
layer(	
	sandstone,
	1,
	(x,z) -> if( mix_hills(x,z) != 0,  mix_hills(x,z) / 100 * complex_cont(x,z) - dirt_depth(x,z), -1)
),
#### simplex_ore(coal_o, (x,z) -> (93 + simplexS(x,132,z, 128) * 72), 654, 23, 86, is_hills, contintent_limit, 2),
#### simplex_ore(iron_o, (x,z) -> (84 + simplexS(x,32,z, 128) * 72), 157, 23, 74, is_hills, contintent_limit, 2),
#### simplex_ore(lapis_o, (x,z) -> (70 + simplexS(x,72,z, 128) * 72), 3189, 23, 65, is_hills, contintent_limit, 3),


layer(
	clay,
	(x,z) -> if( is_hills(x,z), if( steppe( x,z, 80, 128, 24, 5768) > complex_cont(x,z) - dirt_depth(x,z), complex_cont(x,z) - dirt_depth(x,z),  steppe( x,z, 80, 128, 24, 5768)), -1),
	(x,z) -> if( is_hills(x,z), if( steppe( x,z, 80.75, 128, 24, 5768) > complex_cont(x,z) - dirt_depth(x,z), complex_cont(x,z) - dirt_depth(x,z),  steppe( x,z, 80.75, 128, 24, 5768)), -1)
),

layer(
	stone,
	(x,z) -> if( mix_hills(x,z) != 0, if( geology_layer_c(x,z) > complex_cont(x,z) - dirt_depth(x,z), (100 - mix_hills(x,z)) / 100 * geology_layer_c(x,z),  (100 - mix_hills(x,z)) / 100 * geology_layer_c(x,z)), 1),
	(x,z) -> if( is_hills(x,z) || mix_hills(x,z) != 0, if( geology_layer_c(x,z) > complex_cont(x,z) - dirt_depth(x,z), complex_cont(x,z) - dirt_depth(x,z),  geology_layer_c(x,z)), -1)
),
#### simplex_ore(redstone_o, (x,z) -> (56 + simplexS(x,56,z, 128) * 64), 36, 16, 86, is_hills, geology_layer_c, 2),
#### simplex_ore(gold_o, (x,z) -> (44 + simplexS(x,46,z, 128) * 64), 546, 3, 74, is_hills, geology_layer_c, 4),
#### simplex_ore(emerald_o, (x,z) -> (35 + simplexS(x,73,z, 128) * 64), 175, 54, 65, is_hills, geology_layer_c, 4),
layer(
	netherrack,
	1,
	(x,z) -> if( is_hills(x,z), if(geology_layer_b(x,z) > complex_cont(x,z) - dirt_depth(x,z), complex_cont(x,z) - dirt_depth(x,z),  geology_layer_b(x,z)), -1)
),
#Taper off
layer(
	netherrack,
	1,
	(x,z) -> if( mix_hills(x,z) != 0, if(geology_layer_b(x,z) > complex_cont(x,z) - dirt_depth(x,z), complex_cont(x,z) - dirt_depth(x,z),  mix_hills(x,z) / 100 * geology_layer_b(x,z)), -1)
),
#### simplex_ore(netherquartz, (x,z) -> (23 + simplexS(x,89,z, 128) * 64), 879, 45, 86, is_hills, geology_layer_b, 2),
#### simplex_ore(glowstone, (x,z) -> (14 + simplexS(x,269,z, 128) * 64), 698, 65, 74, is_hills, geology_layer_b, 3),
#### simplex_ore(emerald_o, (x,z) -> (7 + simplexS(x,49,z, 128) * 64), 3657, 91, 65, is_hills, geology_layer_b, 3),
#~~
#### #### #### #### #### #### #### #### #### #### #### #### #
# Steppes 
#### #### #### #### #### #### #### #### #### #### #### #### #
#~
layer(
	stone,
	1,
	(x,z) -> if( is_steppe(x,z), complex_cont(x,z) - dirt_depth(x,z), -1)
),
#Taper off 
layer(	
	stone,
	1,
	(x,z) -> if( mix_steppe(x,z) != 0,  mix_steppe(x,z) / 100 * complex_cont(x,z) - dirt_depth(x,z), -1)
),
#### simplex_ore(lapis_o, (x,z) -> (56 + simplexS(x,19,z, 128) * 64), 738, 45, 86, is_steppe, contintent_limit, 2),
#### simplex_ore(iron_o, (x,z) -> (54 + simplexS(x,38,z, 128) * 64), 1236, 65, 74, is_steppe, contintent_limit, 3),
#### simplex_ore(coal_o, (x,z) -> (47 + simplexS(x,46,z, 128) * 64), 9633, 91, 65, is_steppe, contintent_limit, 2),

layer(
	mossycobble,
	(x,z) -> if( mix_steppe(x,z) != 0, if( geology_layer_c(x,z) > complex_cont(x,z) - dirt_depth(x,z), (100 - mix_steppe(x,z)) / 100 * geology_layer_c(x,z),  (100 - mix_steppe(x,z)) / 100 * geology_layer_c(x,z)), 1),
	(x,z) -> if( is_steppe(x,z) || mix_steppe(x,z) != 0, if( geology_layer_c(x,z) > complex_cont(x,z) - dirt_depth(x,z), complex_cont(x,z) - dirt_depth(x,z),  geology_layer_c(x,z)), -1)
),
#### simplex_ore(iron_o, (x,z) -> (49 + simplexS(x,72,z, 128) * 64), 3577, 45, 86, is_steppe, geology_layer_d, 2),
#### simplex_ore(coal_o, (x,z) -> (44 + simplexS(x,36,z, 128) * 64), 6528, 65, 74, is_steppe, geology_layer_d, 2),
#### simplex_ore(iron_o, (x,z) -> (35 + simplexS(x,78,z, 128) * 64), 1257, 91, 65, is_steppe, geology_layer_d, 3),
layer(
	endstone,
	1,
	(x,z) -> if( is_steppe(x,z), if(geology_layer_b(x,z) > complex_cont(x,z) - dirt_depth(x,z), complex_cont(x,z) - dirt_depth(x,z),  geology_layer_b(x,z)), -1)
),
#Taper off
layer(
	endstone,
	1,
	(x,z) -> if( mix_steppe(x,z) != 0, if(geology_layer_b(x,z) > complex_cont(x,z) - dirt_depth(x,z), complex_cont(x,z) - dirt_depth(x,z),  mix_steppe(x,z) / 100 * geology_layer_b(x,z)), -1)
),
#### simplex_ore(redstone_o, (x,z) -> (23 + simplexS(x,89,z, 128) * 64), 879, 45, 86, is_steppe, geology_layer_e, 2),
#### simplex_ore(emerald_o, (x,z) -> (14 + simplexS(x,269,z, 128) * 64), 698, 65, 74, is_steppe, geology_layer_e, 3),
#### simplex_ore(diamond_o, (x,z) -> (7 + simplexS(x,49,z, 128) * 64), 3657, 91, 65, is_steppe, geology_layer_e, 5),

#Ocean -just one extra layer
layer(
	endstone,
	1,
	(x,z) -> if( complex_cont(x,z) < valley_river, valley_river - complex_cont(x,z), -1)
),
#### simplex_ore(gold_o, (x,z) -> (16 + simplexS(x,89,z, 128) * 32), 879, 45, 86, is_valley_ocean, (x,z) -> valley_river - complex_cont(x,z), 2),
#### simplex_ore(emerald_o, (x,z) -> (14 + simplexS(x,269,z, 128) * 32), 698, 65, 74, is_valley_ocean, (x,z) -> valley_river - complex_cont(x,z), 3),
#### simplex_ore(diamond_o, (x,z) -> (7 + simplexS(x,49,z, 128) * 32), 3657, 91, 65, is_valley_ocean, (x,z) -> valley_river - complex_cont(x,z), 3),
#~~
#### #### #### #### #### #### #### #### #### #### #### #### #
#Valley surface
# also default surface, other landforms overwrite this when desired
# do this now so can overwrite any ore extrusions
#### #### #### #### #### #### #### #### #### #### #### #### #
#~
layer(
	dirt,
	(x,z) -> complex_cont(x,z) - bump(x,0,z) - dirt_depth(x,z),
	(x,z) -> if ( complex_cont(x,z) < 120, complex_cont(x,z), -1 )
),

layer(
	grass,
	(x,z) -> complex_cont(x,z) - 1,
	(x,z) -> if ( complex_cont(x,z) < 120, complex_cont(x,z), -1 )
),

# Desert surface in hills and steppes
# also default surface, other landforms overwrite this when desired
layer(
	sand,
	(x,z) -> if( (is_hills(x,z) || is_steppe(x,z)) && select_biome(x,z) == DESERT, complex_cont(x,z) - bump(x,0,z) - dirt_depth(x,z), -1),
	(x,z) -> if( (is_hills(x,z) || is_steppe(x,z)) && select_biome(x,z) == DESERT && complex_cont(x,z) < 120, complex_cont(x,z), -1 )
),

#~~
#### #### #### #### #### #### #### #### #### #### #### #
# River/Ocean		
# Faster to do many layers for each type than to select for each type in a materials if() b/c materials are 3D
#### #### #### #### #### #### #### #### #### #### #### #
#~
#Valley rivers
complex_cont_river( water, valley_river, sand, valley_beach, 1, soulsand, 1, is_valley_river),
complex_cont_river( ice, valley_river, sand, valley_beach, 1, soulsand, 1, is_mix_steppe),
#Try to fix millenaire spawning on bedrock
layer(
		dirt,
		(x,z) -> if( complex_cont(x,z) < valley_river - 2 && is_valley(x,z), complex_cont(x,z) - 4, -1),
		(x,z) -> if( complex_cont(x,z) < valley_river - 2 && is_valley(x,z), complex_cont(x,z) - 2, -1)
	),
#### #Hills rivers
complex_cont_river( water, hills_river, sand, hills_beach, 1, gravel, 1, is_hills),
#### #Steppes rivers
complex_cont_river( water, steppe_river, clay, steppe_beach, 1, clay, 1, is_steppe),
#### #Underground magma rivers in steppes
river( lava, 19.5, lava, 19.5, 1, obsidian, 1, is_steppe, lava_river),
#~~
#### #### #### #### #### #### #### #### #### #### #### #### #
# Caves - only occur in hills 
#### #### #### #### #### #### #### #### #### #### #### #### #
#~
#Using for caves... would also makea good ore system
#### layer(
	#### dirt,
	#### (x,z) -> if( is_hills(x,z) &&  steppe(x,z, 140, 16, 6, 3456) - 1 < 140, steppe(x,z, 140, 16, 6, 3456) - simplexS(x,1234,z,32) * 16, -1),
	#### (x,z) -> if( is_hills(x,z) &&  steppe(x,z, 140, 16, 6, 3456) - 1 < 140, steppe(x,z, 140, 16, 6, 3456) + simplexS(x,647,z,32) * 16, -1)
#### ),

#Narrow Caves
layer(
	air,
	(x,z) -> if( is_hills(x,z) && steppe(x,z, 70, 16, 6, 3456) - 0.75 < 70, 68 - 16 * abs(simplexS(x,123,z,16)), -1),
	(x,z) -> if( is_hills(x,z) && steppe(x,z, 70, 16, 6, 3456) - 0.75 < 70, 70 + 16 * abs(simplexS(x,498,z,16)), -1)
),
#Wider caves
layer(
	air,
	(x,z) -> if( is_hills(x,z) && steppe(x,z, 50, 32, 6, 46544) - 1.75 < 170, 53 - 32 * abs(simplexS(x,984,z,32)), -1),
	(x,z) -> if( is_hills(x,z) &&  steppe(x,z, 50, 32, 6, 46544) - 1.75 < 170, 50 + 32 * abs(simplexS(x,347,z,32)), -1)
),
#Deep caves- Underground world inspired by Dwarf Fortress, Mystcraft cave worlds, and Togos mapscript
living_cave( air, mycelium, 1, water, 12, glowstone, 1.5, obsidian, 1, 24, deep_cave_floor, deep_cave_roof, is_hills),
#~~
#### #### #### #### #### #### #### #### #### #### #### #### #
# Volcanics
#### #### #### #### #### #### #### #### #### #### #### #### #
#~
layer(
	mossycobble,
	1,
	(x,z) -> ridge(1, volcano_alt, volcano(x,z))
),
layer(
	lava,
	(x,z) -> ridge(1, volcano_alt, volcano(x,z)),
	(x,z) -> if( volcano(x,z) > volcano_alt, lava_alt, -1)
),
#### simplex_ore(lava, (x,z) -> (12 + simplexS(x,54,z, 128) * 32), 6877, 45, 86,(x,z) ->  volcano(x,z) > 0, (x,z) -> ridge(1, volcano_alt, volcano(x,z)), 2),
#### simplex_ore(gold_o, (x,z) -> (16 + simplexS(x,43,z, 128) * 32), 3698, 45, 86,(x,z) ->  volcano(x,z) > 0, (x,z) -> ridge(1, volcano_alt, volcano(x,z)), 2),
#### simplex_ore(emerald_o, (x,z) -> (14 + simplexS(x,89,z, 128) * 32), 258, 65, 74,(x,z) ->  volcano(x,z) > 0, (x,z) -> ridge(1, volcano_alt, volcano(x,z)), 3),
#### simplex_ore(diamond_o, (x,z) -> (7 + simplexS(x,13,z, 128) * 32), 768, 91, 65,(x,z) ->  volcano(x,z) > 0, (x,z) -> ridge(1, volcano_alt, volcano(x,z)), 3),
#### #Higher ores
#### simplex_ore(lava, (x,z) -> (53 + simplexS(x,74,z, 128) * 64), 9524, 45, 86,(x,z) ->  volcano(x,z) > 0, (x,z) -> ridge(1, volcano_alt, volcano(x,z)), 2),
#### simplex_ore(gold_o, (x,z) -> (60 + simplexS(x,46,z, 128) * 64), 2587, 45, 86,(x,z) ->  volcano(x,z) > 0, (x,z) -> ridge(1, volcano_alt, volcano(x,z)), 3),
#### simplex_ore(emerald_o, (x,z) -> (44 + simplexS(x,91,z, 128) * 64), 4568, 65, 74,(x,z) ->  volcano(x,z) > 0, (x,z) -> ridge(1, volcano_alt, volcano(x,z)), 2),
#### simplex_ore(diamond_o, (x,z) -> (37 + simplexS(x,67,z, 128) * 64), 1257, 91, 65,(x,z) ->  volcano(x,z) > 0, (x,z) -> ridge(1, volcano_alt, volcano(x,z)), 3),

#~~
#### #### #### #### #### #### #### #### #### #### #### #### #
# Floating Islands --only above the sea
#### #### #### #### #### #### #### #### #### #### #### #### #
#~
#interesting landform
#### layer(
	#### dirt,
	#### 128,
	#### (x,z) -> 128 + 128 * bezierR(steppes(x,z) / 176, 0, 1, -.25, 1)
#### ),

# Xeen like cloud roads
river( snow, 181.75, ice, 182.75, 1, ice, 1, is_floating_isle, floating_isle_river),
# Actual floating islands
living_cave( dirt, ice, 3, snow, 181, dirt, 1, grass, 1, 180, floating_isle_floor, floating_isle_roof, is_floating_isle),
#~~
#### #### #### #### #### #### #### #### #### #### #### #### #
# Grid Lines and Bedrock
#### #### #### #### #### #### #### #### #### #### #### #### #
#~
#### layer(
	#### bedrock,
	#### 219,
	#### 220
#### ),

#### layer(
	#### bedrock,
	#### 229,
	#### 230
#### ),

#### #chunk grid
#### layer (
	#### bedrock,
	#### 0,
	#### (x,z) -> if ( 
		#### ridge( 0,1, (x / 16)) == 1, 
		#### 250,
		#### ridge( 0,1, ((x + 16) / 16)) == 1,
		#### 250,		
		#### -1
		#### )
#### ),
#### layer (
	#### bedrock,
	#### 0,
	#### (x,z) -> if ( 
		#### ridge( 0,1, (z / 16)) == 1, 
		#### 250,
		#### ridge( 0,1, ((z + 16) / 16)) == 1,
		#### 251,		
		#### -1
		#### )
#### ),
#### #region grid
layer (
	air,
	0,
	(x,z) -> if ( 
		ridge( 0,256, x - 256) > 240, 
		254,		
		-1
		)
),
layer (
	air,
	0,
	(x,z) -> if ( 
		ridge( 0,256, z - 256) > 240,
		254,		
		-1
		)
),
layer (
	air,#bedrock,
	0,
	(x,z) ->  if ( 
		(x >= (xstart_chunk * 16 ) ) and (x <= ((xstart_chunk + 1) * 16) ), 
		227,
		(x <= ((chunksx + xstart_chunk) * 16) ) and (x >= ((chunksx + xstart_chunk - 1) * 16) ),
		227,		
		-1
		)
),
layer (
	air,#bedrock,
	0,
	(x,z) -> if ( 
		(z >= (zstart_chunk * 16) ) and (z <= ((zstart_chunk + 1) * 16) ), 
		227,
		(z <= ((chunksz + zstart_chunk) * 16) ) and (z >= ((chunksz + zstart_chunk - 1) * 16) ),
		227,		
		-1
		)
),
layer( bedrock, 0, 1),
#~~
#### #Biome testing
#### layer(
	#### (x,y,z) -> select_biome_test(x,z),
	#### 1,
	#### (x,z) -> complex_cont(x,z)
#### ),
biome @ (x,z) -> select_biome(x,z)
#lighter
#Not working atm
#populated
);
#~~

				
###########################################################################################################################################				
# Basic Math Functions
###########################################################################################################################################				
#~				
floor( a ) = (a - (a % 1));					
abs( a ) = ( if( a < 0, a * -1,  a) );
pos( a ) = ( if( a < 0, 0,  a) );
#Scaled versions of basic noise functions
perlinS( x,y,z, scale) = perlin( x / scale, y, z / scale);
simplexS( x,y,z, scale) = simplex( x / scale, y, z / scale);

radius( _x, _z, radius_x, radius_z, blend_radius, perturb_scale, perturb_multiplier, seed ) = (
		x = _x + xstart + abs(simplexS(_x, seed,_z, perturb_scale)) * perturb_multiplier;
		z = _z + zstart + abs(simplexS(_x, seed,_z, perturb_scale)) * perturb_multiplier;
		pow_d = ((radius_x - (x)) ** 2 + (radius_z - (z)) ** 2) ** 0.5;
		blend_radius - pow_d
);
#Generates an ellipse
radius_e( _x, _z, center_x, center_z, x_width, z_width, blend_radius, perturb_scale, perturb_multiplier, seed ) = (
		x = _x + xstart + abs(simplexS(_x, seed,_z, perturb_scale)) * perturb_multiplier;
		z = _z + zstart + abs(simplexS(_x, seed,_z, perturb_scale)) * perturb_multiplier;
		percent = 1 - ((x - center_x) ** 2 / x_width ** 2) - ((z - center_z) ** 2 / z_width ** 2);
		percent * blend_radius
);
#~~				
###########################################################################################################################################				
# Random Number Functions
###########################################################################################################################################	
#~
#http://www0.cs.ucl.ac.uk/staff/d.jones/GoodPracticeRNG.pdf
#### /*
#### Public domain code
#### for JKISS RNG
#### */
#### static unsigned int
#### x = 123456789,y = 987654321,z = 43219876,c = 6543217; /* Seed variables */
#### unsigned int JKISS()
#### {
#### unsigned long long t;
#### x = 314527869 * x + 1234567;
#### y ^= y << 5;
#### y ^= y >> 7;
#### y ^= y << 22;
#### t = 4294584393ULL * z + c;
#### c = t >> 32;
#### z = t;
#### return x + y + z;
#### }


kiss( _x, _z ) = (
x = 123456789.0 + _x; y = 987654321.0; z = 43219876.0 + _z; c = 6543217.0; #/* Seed variables */
x1 = 314527869.0 * x + 1234567.0;
y1 = y ^ (y << 5);
y2 = y1 ^ (y1 >> 7);
y3 = y2 ^ (y2 << 22);
t = 4294584393.0 * z + c;
#c = t >> 32;
#z = t;
floor(x1 + y3 + t) / 2#(2 ** 0)
);
			

#glibc LCG for fun because we can, not vecorizable so slooow, 2147483648 is too big for an int
#lcg( s ) =  ((s * 1103515245 + 12345) % 2147483648 ) >> 4;	#Shift is my addition to eliminate lower order bits which are usually less random

#This is vectorizable but no longer original so who knows about it's quality
#Normally not calling multiple times from a single seed anyway.
randBig( s ) = (s * 1103515245 + 12345) % 2147483648.0;		

#Should map into 0-1
rand( s ) =  randBig(s) / 2147483648.0;							
rand+-( s ) = (rand(s) - 0.5) * 2;
#Calls rand i number of times to enure randomness
randfrac( i, s ) = (
	v = rand( s );
	if ( i <= 1, 
		v,
		randfrac( i - 1, v) 
		)
);

#Primitive Gaussian RNG
sumrandfrac( i, s ) = (
	v = rand( s ) * 2 - 1;
	if ( i <= 1, 
		v,
		v + sumrandfrac( i - 1, v) 
		)
);
#should be distributes over -1 to 1, so mean should be 0
#quality depends on number of iterations, i
randgauss ( i, s, deviation, mean) = (
	sumrandfrac(i, s) * deviation + mean
);
	
#Generates a random number for the given x,z pair. 
#Values aren't gauranteed to be unique but don't display any noticable patterns
#Borrowed basic algorithm from Minecraft's code 
randXZBig( x, z ) = (
	n3 = (x * rand(x) + x) * rand( x * rand(x) + x );
	n4 = n3 + z + 2147483562;
	
	n5 = n4 * rand( n4 );
	n6 = n5 + x;
	n7 = n6 * rand( n6 );
	((n7 + z) % 2147483647)
);
#Should map randXZBig into 0-1
randXZ( x, z ) = (
	randXZBig( x, z ) / 2147483647.0
);
#Should map randXZBig into -1 to 1
randXZ+-( x, z ) = (
	((randXZBig( x, z ) / 2147483647.0) - 0.5) * 2
);
#Possibly a better implementation for 3 seed rng?
randXYZBig( x, y, z ) = (
	randXZBig( randXZBig(x,z), y)	
);
#### #Not sure if is truly random over all 3 axis
#### #y axis seems to display a pattern
#### randXYZBig( x, y, z ) = (
	#### n3 = (x * randP(x) + x) * randP( x * randP(x) + x );
	#### n4 = n3 + z + 2147483562;
	
	#### n5 = n4 * randP( n4 );
	#### n6 = n5 + x;
	#### n7 = n6 * randP( n6 );
	
	#### n8 = (n7 + z) * randP( (n7 + z) );
	#### n9 = n8 + y;
	#### n10 = n9 * randP( n9 );
	#### abs((n10 + y) % 2147483647)
#### );
#### #Should map randXZBig into 0-1
randXYZ( x, y, z ) = (
	randXYZBig( x, y, z ) / 2147483647
);
#~~
###########################################################################################################################################				
# Curving Functions
###########################################################################################################################################				
#~
#Linear Interpolation or lerp
#formula as described by wikipedia, probably not the most computer efficent method
#Compatible with variable distance points
lerp ( x, p1x, p2x, p1value, p2value ) = (
	p1value + (p2value - p1value) * (( x - p1x) / (p2x - p1x))
);

#Takes input point u,v and calculates it position on a grid scale times larger
# and interpolates a value based on it's position relative to points p1,p2, p3,p4
# and their values. p1 & p2 are on the x axis; p3 & p4 are on the z axis
lerp2D( u,v, scale, p1, p2, p3, p4 ) = (
	sX = (u % scale) / scale;
	sZ = (v % scale) / scale;
	(p1 * (1 - sX) * (1 - sZ)) + 
		(p2 * (1 - sZ) * sX) + 
		(p3 * (1 - sX) * sZ) + 
		(p4 * sX * sZ)
);
#These are all one dimension bezier curves, so t=y when graphing. As an effect of this they cannot be made to intersect themsleves or loop.
#http://www.sulaco.co.za/downloads.htm has a useful tool for visualizing Bezier curves or use this:
#128 * bezierA(x % 256 / 256, 0, .25, .25, .5);
#Predefined bezier curve
curve( t ) = ((1 - t ) * (1 - t ) * t * 0.75) + ( t * t * ( 1 - t ) * -0.75) + ( t * t * t);
#Cubic bezier, i.e. it has two control points
#Implied "x" is 0 for a and 1 for b, values assigned are the "y" values
bezier( t, s, a, b, e) = (
	invt = 1 - t;
	(invt ** 3) * s + 3 * (invt ** 2) * t * b + 3 * invt * (t ** 2) * a + (t ** 3) * e
);
#Cubic bezier with all contol points, implied "x" is 1 for a and 0 for b
#Because weights are backwards the function has a plateau in the middle that is impossible to produce with bezierA
bezierR( t, s, a, b, e) = (
	invt = 1 - t;
	(invt ** 3) * s + 3 * (invt ** 2) * t * a + 3 * invt * (t ** 2) * b + (t ** 3) * e
);
#~~
###########################################################################################################################################				
# Noise Functions
###########################################################################################################################################				
#~
#### #### #### #### #
#### Midpoint Noise
#### #### #### #### #
#~
midpoint1D( iter, Hscale, Vscale, Hdelta, Vdelta, v) = (
	p1 = lcgfrac( 3, floor( v / Hscale)) * Vscale;
	p2 = lcgfrac( 4, 1 + floor( v / Hscale)) * Vscale;
	if( iter < 1,
			(p2 - p1) * ((v % Hscale) / Hscale)   + p1,
			((p2 - p1) * ((v % Hscale) / Hscale) + p1) + midpoint1D( iter - 1, Hscale * Hdelta, Vscale * Vdelta, Xdelta, Hdelta, v)
	)
);

#Not a true midpoint algorithm, really all it does is combine weighted
#planes of interpolated random numbers on different scales. The
#values of the previous octave are irrelevent
#by offsetting one axis every second iteration some of the artifacts are eliminated
midpoint( iter, Hscale, Vscale, Hdelta, Vdelta, Rscale, q, w) = (
	x = (floor(q / Hscale)) + if (iter % 2 < 1, 0, 0.5);
	z = (floor(w / Hscale));# + if (iter % 2 < 1, 0, 0.5);
	p1 = randXZ(x, z) * Rscale;
	p2 = randXZ(x + 1, z) * Rscale;
	p3 = randXZ(x, z + 1) * Rscale;	
	p4 = randXZ(x + 1, z + 1) * Rscale;
	#Bilinear interpolation taken from Wikipedia
	sX = (q % Hscale) / Hscale;
	sZ = (w % Hscale) / Hscale;
	v = (p1 * (1 - sX) * (1 - sZ)) + 
		(p2 * (1 - sZ) * sX) + 
		(p3 * (1 - sX) * sZ) + 
		(p4 * sX * sZ);
	if ( iter <= 1,
		v * Vscale,
		(v * Vscale) + midpoint( iter - 1, Hscale * Hdelta, Vscale * Vdelta, Hdelta, Vdelta, Rscale, q, w)
	)

);

# One pass midpoint
randomPlane( q,w, Hscale, Vscale, Rscale) = (
	x = (floor(q / Hscale));
	z = (floor(w / Hscale));# + if (iter % 2 < 1, 0, 0.5);
	p1 = randXZ(x, z) * Rscale;
	p2 = randXZ(x + 1, z) * Rscale;
	p3 = randXZ(x, z + 1) * Rscale;	
	p4 = randXZ(x + 1, z + 1) * Rscale;
	#Bilinear interpolation taken from Wikipedia
	sX = (q % Hscale) / Hscale;
	sZ = (w % Hscale) / Hscale;
	v = (p1 * (1 - sX) * (1 - sZ)) + 
		(p2 * (1 - sZ) * sX) + 
		(p3 * (1 - sX) * sZ) + 
		(p4 * sX * sZ);
	v * Vscale

);

midpoint3D( iter, Hscale, Vscale, Hdelta, Vdelta, Rscale, q, e, w) = (
	x = (floor(q / Hscale)) + if (iter % 2 < 1, 0, 0.5);
	z = (floor(w / Hscale));# + if (iter % 2 < 1, 0, 0.5);
	y = (floor(e / Hscale));
	p1 = randXYZ(x, y, z) * Rscale;
	p2 = randXYZ(x + 1, y, z) * Rscale;
	p3 = randXYZ(x, y, z + 1) * Rscale;	
	p4 = randXYZ(x + 1, y, z + 1) * Rscale;
	
	p5 = randXYZ(x, y + 1, z) * Rscale;
	p6 = randXYZ(x + 1, y + 1, z) * Rscale;
	p7 = randXYZ(x, y + 1, z + 1) * Rscale;	
	p8 = randXYZ(x + 1, y + 1, z + 1) * Rscale;
	
	#Trilinear interpolation taken from 
	#http://paulbourke.net/miscellaneous/interpolation/
	sX = (q % Hscale) / Hscale;
	sZ = (w % Hscale) / Hscale;
	sY = (e % Hscale) / Hscale;
	iX = (1 - sX);
	iZ = (1 - sZ);
	iY = (1 - sY);
	
	v = (p1 * iX * iY * iZ) + 
		(p2 * sX * iY * iZ) + 
		(p5 * iX * sY * iZ) + 
		(p3 * iX * iY * sZ) +
		(p4 * sX * iY * sZ) + 
		(p7 * iX * sY * sZ) + 
		(p6 * sX * sY * iZ) + 
		(p8 * sX * sY * sZ);
		
	if ( iter <= 1,
		v * Vscale,
		(v * Vscale) + midpoint3D( iter - 1, Hscale * Hdelta, Vscale * Vdelta, Hdelta, Vdelta, Rscale, q, e, w)
	)

);

#Uses an average rather than interpolation
midpointAvg( iter, Hscale, Vscale, Hdelta, Vdelta, Rscale, q, w) = (
	x = (floor(q / Hscale)) + if (iter % 2 < 1, 0, 0.5);
	z = (floor(w / Hscale));# + if (iter % 2 < 1, 0, 0.5);
	p1 = randXZ(x, z) * Rscale;
	p2 = randXZ(x + 1, z) * Rscale;
	p3 = randXZ(x, z + 1) * Rscale;	
	p4 = randXZ(x + 1, z + 1) * Rscale;
	v = ( p1 + p2 + p3 + p4) / 4;
	if ( iter <= 1,
		v * Vscale,
		(v * Vscale) + midpoint( iter - 1, Hscale * Hdelta, Vscale * Vdelta, Hdelta, Vdelta, Rscale, q, w)
	)

);
#~~
#### #### #### #### #
#### Voronoi Noise
#### #### #### #### #
#~
#### Voronoi Distance Formulas
# ~
####	Vornonoi expect distance functions that take 4 arguments, x,z and px,pz
#### this allows any distance function to be made. Custom offsets and stretching 
#### can be applied by rewriting these formulas into new functions.
#### _template( x,z, px, pz ) = x + z;
#### #Manhattan
_manhattan(x,z, px,pz ) = abs( x - px ) + abs( z - pz);

#### #Chebyshev distance -not really useful for cells but okay for random
_chebyshev( x,z, px,pz ) = if(abs( x - px ) > abs( z - pz ), abs( x - px ), abs( z - pz ));

#### #Euclidean distance w/o the root
_power( x,z, px,pz ) = abs( x - px ) ** 2 + abs( z - pz ) ** 2;
	
#### #Minkowski distance - does everything, but a lot of math
#### #In order for this to work need a value assigned to n
#### #n = 1 is Manhattan distance, 2 is Euclidean, infinity is Chebyshev
#### _minkowski ( x,z, px,pz ) = (abs( x - px ) ** n + abs( z - pz ) ** n) ** (1 / n);
##~~

#### Voronoi Value Functions
#~
#These functions are meant to be passed to voronoi in order to calculate the value it returns 
#u,v are the scaled cords of the closest points, i.e. the cell the block caclulating for is in
#_1,_2,_3 are the distances to the closest three points as calculated by _distance in voronoi
#param, w1, w2, w3 are parameters passed in from voronoi 
#_template( u,v, param, d1, w1, d2, w2, d3, w3 ) = d1;
_voronoiStd( u,v, param, _1, w1, _2, w2, _3, w3 ) = param + (_1 * w1) + (_2 * w2) + (_3 * w3);
_lines(  u,v, param, _1, w1, _2, w2, _3, w3 ) = if( abs(_2) - abs(_1) < 0.025, 255, 0);
_v_rand( u,v, param, _1, w1, _2, w2, _3, w3 ) = randXZ(u,v);
#~~
#### Voronoi Presets
#~
#Returns a random number for the cell the block is in
voronoiRand( _x,_z, scale, r ) = voronoi( _x,_z, scale, r, 0, 0, 0, 0, _power, _v_rand );
#Returns the weighted addition of the closest three points
voronoiCell( _x,_z, scale, r, add, weight1, weight2, weight3 ) = voronoi( _x,_z, scale, r, add, weight1, weight2, weight3, _power, _voronoiStd );
#Returns an integer {i| 0 <= i < n } randomly assigned to each cell
voronoiTiles( _x,_z, scale, randomness, number )  = floor((voronoi( _x,_z, scale, randomness, 0, 0, 0, 0, _power, _v_rand ) * number) % number);

####Complex Voronoi Presets - need to be converted to new voronoiCell arguments
#### Very cool mountains and valleys with ridged structure and benches on mountains,
#### has some ridge artifacts
#### ((voronoiCell( x, z, 256, 0.70, -8, 3.5) * 1)) * 16 
				#### + ((voronoiCell( x, z, 128, 0.70, -8, -3.5) * 1) ) * 4
				#### + ((voronoiCell( x, z, 64, 0.70, -8, 3.5) * 1) ) * 2
#### Inverse of above function, has a bubbly smooth texture
#### ((voronoiCell( x, z, 256, 0.70, 8, -3.5) * 1)) * 16 
				#### + ((voronoiCell( x, z, 128, 0.70, 8, 3.5) * 1) ) * 4
				#### + ((voronoiCell( x, z, 64, 0.70, 8, -3.5) * 1) ) * 2
#### Combination of above two, rolling flats and sharp mountains with deep valleys between
#### abs(((voronoiCell( x, z, 256, 0.70, 8, -3.5) * 1)) * 16 
				#### + ((voronoiCell( x, z, 128, 0.70, 8, 3.5) * 1) ) * 4
				#### + ((voronoiCell( x, z, 64, 0.70, 8, -3.5) * 1) ) * 2)
#~~
#### Voronoi Functions 
#~
	
#Based on points in the center of each region
#q,w are coords for block; scale is scale of cells, r is multiplier for randomness
#To yeild a diagram of n values: (voronoiRand() * n) % n

#When trying to implement alternate grids to randomize, it's important to remember that the algorithm should include
#all the points in the surrounding sections, otherwise tiling will result. Never got a hex base grid to work w/o tiling.
#Max value can return should be (1 + (2 * r)) ** 2

#Contains a bias due to ties in distance always going one way.
voronoi( _x,_z, scale, r, func_param, weight1, weight2, weight3, _distance, _func ) = (
#~
	x = floor(_x / scale) + 0.5;
	z = floor(_z / scale) + 0.5;
	
	#Top Row
	p1x = x - 1 + randXZ+-(x - 1, z - 1) * r;
	#p1z = z - 1 + randXZ+-(z - 1, x - 1) * r;
	p1z = z - 1 + rand+-(rand+-(rand+-(randXZBig(x - 1, z - 1)))) * r;
	
	p2x = x + randXZ+-(x, z - 1) * r;
	#p2z = z - 1 + randXZ+-(z - 1, x) * r;
	p2z = z - 1 + rand+-(rand+-(rand+-(randXZBig(x, z - 1)))) * r;
	
	p3x = x + 1 +  randXZ+-(x + 1, z - 1) * r;
	#p3z = z - 1 + randXZ+-(z - 1, x + 1) * r;
	p3z = z - 1 + rand+-(rand+-(rand+-(randXZBig(x + 1, z - 1)))) * r;
	
	#Middle Row
	p4x = x - 1 +  randXZ+-(x - 1, z) * r;
	#p4z = z + randXZ+-(z, x - 1) * r;
	p4z = z + rand+-(rand+-(rand+-(randXZBig(x - 1, z)))) * r;
	
	p0x = x + randXZ+-(x, z ) * r;
	#p0z = z + randXZ+-(z, x ) * r;
	p0z = z + rand+-(rand+-(rand+-(randXZBig(x, z )))) * r;
	
	p5x = x + 1 +  randXZ+-(x + 1, z) * r;
	#p5z = z + randXZ+-(z, x + 1) * r;
	p5z = z + rand+-(rand+-(rand+-(randXZBig(x + 1, z)))) * r;
	
	#Bottom Row
	p6x = x - 1 + randXZ+-(x - 1, z + 1) * r;
	#p6z = z + 1 + randXZ+-(z + 1, x - 1) * r;
	p6z = z + 1 + rand+-(rand+-(rand+-(randXZBig(x - 1, z + 1)))) * r;
	
	p7x = x +  randXZ+-(x, z + 1) * r;
	#p7z = z + 1 + randXZ+-(z + 1, x ) * r;
	p7z = z + 1 + rand+-(rand+-(rand+-(randXZBig(x, z + 1)))) * r;
	
	p8x = x + 1 + randXZ+-(x + 1, z + 1) * r;
	#p8z = z + 1 + randXZ+-(z + 1, x + 1) * r;
	p8z = z + 1 + rand+-(rand+-(rand+-(randXZBig(x + 1, z + 1)))) * r;
	
	u = _x / scale;
	v = _z / scale;

	n_w =  _distance( u,v, p1x, p1z);
	north =  _distance( u,v, p2x, p2z);
	n_e =  _distance( u,v, p3x, p3z);
	west =  _distance( u,v, p4x, p4z);
	east =  _distance( u,v, p5x, p5z);
	s_w =  _distance( u,v, p6x, p6z);
	south =  _distance( u,v, p7x, p7z);
	s_e =  _distance( u,v, p8x, p8z);	
	i =  _distance( u,v, p0x, p0z);
	
	#because TMCMG bails from if on first true for speed it's important that test against points most likely to be closest first
	#not actually borne out by tests, came out about the same time for 128x128 map but will use this in case
	if(
		compare8(i, north, west, east, south, n_w, n_e, s_w, s_e ),
			(_smallest2Of8( north, west, east, south, n_w, n_e, s_w, s_e, weight2, weight3, i, weight1, _func, func_param, p0x, p0z )),
		
		compare8(north, west, east, south, n_w, i, n_e, s_w, s_e ),
			(_smallest2Of8( west, east, south, n_w, i, n_e, s_w, s_e, weight2, weight3, north, weight1, _func, func_param, p2x,p2z )),
		compare8(west, i, north, east, south, n_w, n_e, s_w, s_e ),
			(_smallest2Of8( i, north, east, south, n_w, n_e, s_w, s_e , weight2, weight3, west, weight1, _func, func_param, p4x,p4z )),
		compare8(east, i, north, west, south, n_w, n_e, s_w, s_e ),
			(_smallest2Of8( i, north, west, south, n_w, n_e, s_w, s_e, weight2, weight3, east, weight1, _func, func_param, p5x,p5z )),
		compare8(south, i, north, west, east, n_w, n_e, s_w, s_e ),
			(_smallest2Of8( i, north, west, east, n_w, n_e, s_w, s_e, weight2, weight3, south, weight1, _func, func_param, p7x,p7z )),			
		
		compare8(n_w, i, north, west, east, south, n_e, s_w, s_e ),
			(_smallest2Of8( i, north, west, east, south, n_e, s_w, s_e, weight2, weight3, n_w, weight1, _func, func_param, p1x,p1z )),
		compare8(n_e, i, north, west, east, south, n_w, s_w, s_e ),
			(_smallest2Of8( i, north, west, east, south, n_w, s_w, s_e, weight2, weight3, n_e, weight1, _func, func_param, p3x,p3z )),
		compare8(s_w, i, north, west, east, south, n_w, n_e, s_e ),
			(_smallest2Of8( i, north, west, east, south, n_w, n_e, s_e, weight2, weight3, s_w, weight1, _func, func_param, p6x,p6z )),
		compare8(s_e, i, north, west, east, south, n_w, n_e, s_w ),
			(_smallest2Of8( i, north, west, east, south, n_w, n_e, s_w, weight2, weight3, s_e, weight1, _func, func_param, p8x,p8z )),
		0
	)

);
#~~


#fairly slow, esp if used for 3D noise
voronoiCell3D( _x,_y,_z, scale, r, add, weight1, weight2 ) = (
#~
	x = floor(_x / scale);
	y = floor(_y / scale);
	z = floor(_z / scale);
	
	u = _x / scale;
	v = _z / scale;
	w = _y / scale;
	
	x_off = if( u > 0.75, 1, 0);
	y_off = if( w > 0.75, 1, 0);
	z_off = if( v > 0.75, 1, 0);
	#Disable lattice system and only use cube points
	corner = 0;#if( (u > 0.75) || (u < 0.25) || (v > 0.75) || (v < 0.25) || (w > 0.75) || (w < 0.25), 1, 0 );
	
	#### Two lattice system:
	#### Use depends on where in box x,y,z is, if it's near a corner then switch to the 2nd lattice 
	#### .__.     . . 
	#### |\.|\.    \|
	#### '\|'\|  .~~o~~.
	####   '~~'     |\
	####            ' '
	
	#bottom corner - center
	p0x = if( corner == 0, x + randXYZ(x, y, z ) * r,  x + x_off + randXYZ(x, y, z ) * r);
	p0z = if( corner == 0, z + randXYZ(z, y, x ) * r,  z + z_off + randXYZ(z, y, x ) * r);
	p0y = if( corner == 0, y + randXYZ(z, x, y ) * r,  y + y_off + randXYZ(z, x, y ) * r);
	#plus one on z axiz
	p1x = if( corner == 0, x + randXYZ(x, y, z + 1 ) * r,  x + x_off + randXYZ(x, y, z + 1 ) * r);
	p1z = if( corner == 0, z + 1 + randXYZ(z + 1, y, x ) * r,  z + 1 + z_off + randXYZ(z + 1, y, x ) * r);
	p1y = if( corner == 0, y + randXYZ(z + 1, x, y ) * r,  y + y_off + randXYZ(z, x, y ) * r);
	#plus one on x axis
	p2x = if( corner == 0, x + 1 + randXYZ(x + 1, y, z ) * r,  x + x_off + randXYZ(x, y, z - 1 ) * r);
	p2z = if( corner == 0, z + randXYZ(z, y, x + 1 ) * r,  z - 1 + z_off + randXYZ(z - 1, y, x ) * r);
	p2y = if( corner == 0, y + randXYZ(z, x + 1, y ) * r,  y + y_off + randXYZ(z, x, y ) * r);
	#plus one on both axis
	p3x = if( corner == 0, x + 1 + randXYZ(x + 1, y, z + 1 ) * r,  x - 1 + x_off + randXYZ(x - 1, y, z ) * r);
	p3z = if( corner == 0, z + 1 + randXYZ(z + 1, y, x + 1 ) * r,  z + z_off + randXYZ(z, y, x - 1 ) * r);
	p3y = if( corner == 0, y + randXYZ(z + 1, x + 1, y ) * r,  y + y_off + randXYZ(z, x, y ) * r);
	
	#next y level
	#bottom corner - center
	p4x = if( corner == 0, x + randXYZ(x, y + 1, z ) * r,  x + 1 + x_off + randXYZ(x + 1, y, z ) * r);
	p4z = if( corner == 0, z + randXYZ(z, y + 1, x ) * r,  z + z_off + randXYZ(z, y, x + 1 ) * r);
	p4y = if( corner == 0, y  + 1 + randXYZ(z, x, y + 1) * r,  y + y_off + randXYZ(z, x, y ) * r);
	#plus one on z axiz
	p5x = if( corner == 0, x + randXYZ(x, y + 1, z + 1 ) * r,  x + x_off + randXYZ(x, y - 1, z ) * r);
	p5z = if( corner == 0, z + 1 + randXYZ(z + 1, y + 1, x ) * r,  z + z_off + randXYZ(z, y - 1, x ) * r);
	p5y = if( corner == 0, y + 1 + randXYZ(z + 1, x, y + 1 ) * r,  y - 1 + y_off + randXYZ(z, x, y - 1 ) * r);
	#plus one on x axis
	p6x = if( corner == 0, x + 1 + randXYZ(x + 1, y + 1, z ) * r,  x + x_off + randXYZ(x, y + 1, z ) * r);
	p6z = if( corner == 0, z + randXYZ(z, y + 1, x + 1 ) * r,  z + z_off + randXYZ(z, y + 1, x ) * r);
	p6y = if( corner == 0, y + 1 + randXYZ(z, x + 1, y + 1 ) * r,  y + 1 + y_off + randXYZ(z, x, y + 1 ) * r);
	#plus one on both axis
	p7x = if( corner == 0, x + 1 + randXYZ(x + 1, y + 1, z + 1 ) * r,  20);
	p7z = if( corner == 0, z + 1 + randXYZ(z + 1, y + 1, x + 1 ) * r,  20);
	p7y = if( corner == 0, y + 1 + randXYZ(z + 1, x + 1, y + 1 ) * r,  20);
	
	
	
	#Euclidean distance w/o the root
	a =  abs( u - p1x ) ** 2 + abs( v - p1z ) ** 2 + abs( w - p1y ) ** 2;
	b =  abs( u - p2x ) ** 2 + abs( v - p2z ) ** 2 + abs( w - p2y ) ** 2;
	c =  abs( u - p3x ) ** 2 + abs( v - p3z ) ** 2 + abs( w - p3y ) ** 2;
	d =  abs( u - p4x ) ** 2 + abs( v - p4z ) ** 2 + abs( w - p4y ) ** 2;
	e =  abs( u - p5x ) ** 2 + abs( v - p5z ) ** 2 + abs( w - p5y ) ** 2;
	f =  abs( u - p6x ) ** 2 + abs( v - p6z ) ** 2 + abs( w - p6y ) ** 2;
	g =  abs( u - p7x ) ** 2 + abs( v - p7z ) ** 2 + abs( w - p7y ) ** 2;
	h =  20000; #abs( u - p8x ) ** 2 + abs( v - p8z ) ** 2;
	i =  abs( u - p0x ) ** 2 + abs( v - p0z ) ** 2 + abs( w - p0y ) ** 2;
	
	if(
		compare8(i, a, b, c, d, e, f, g, h ),
		add + i * weight1 + weight2 * smallestOf8( a, b, c, d, e, f, g, h ),
		compare8(a, i, b, c, d, e, f, g, h ),
		add + a * weight1 + weight2 * smallestOf8( i, b, c, d, e, f, g, h ),
		compare8(b, a, i, c, d, e, f, g, h ),
		add + b * weight1 + weight2 * smallestOf8( a, i, c, d, e, f, g, h ),
		compare8(c, a, b, i, d, e, f, g, h ),
		add + c * weight1 + weight2 * smallestOf8( a, i, c, d, e, f, g, h ),
		compare8(d, a, b, c, i, e, f, g, h ),
		add + d * weight1 + weight2 * smallestOf8( a, b, c, i, e, f, g, h ),
		compare8(e, a, b, c, d, i, f, g, h ),
		add + e * weight1 + weight2 *	smallestOf8( a, b, c, d, i, f, g, h ),
		compare8(f, a, b, c, d, e, i, g, h ),
		add + f * weight1 + weight2 * smallestOf8( a, b, c, d, e, i, g, h ),
		compare8(g, a, b, c, d, e, f, i, h ),
		add + g * weight1 + weight2 * smallestOf8( a, b, c, d, e, f, i, h ),			
		compare8(h, a, b, c, d, e, f, g, i ),
		add + h * weight1 + weight2 * smallestOf8( a, b, c, d, e, f, g, i ),
		0
	)

);
#~~
voronoiRand3D( _x,_y,_z, scale, r ) = (
#~
	x = floor(_x / scale);
	y = floor(_y / scale);
	z = floor(_z / scale);
	
	u = _x / scale;
	v = _z / scale;
	w = _y / scale;
	
	x_off = if( u > 0.75, 1, 0);
	y_off = if( w > 0.75, 1, 0);
	z_off = if( v > 0.75, 1, 0);
	corner = 0;#if( (u > 0.75) || (u < 0.25) || (v > 0.75) || (v < 0.25) || (w > 0.75) || (w < 0.25), 1, 0 );
	
	#### Two lattice system:
	#### Use depends on where in box x,y,z is, if it's near a corner then switch to the 2nd lattice 
	#### .__.     . . 
	#### |\.|\.    \|
	#### '\|'\|  .~~o~~.
	####   '~~'     |\
	####            ' '
	
	#bottom corner - center
	p0x = if( corner == 0, x + randXYZ(x, y, z ) * r,  x + x_off + randXYZ(x, y, z ) * r);
	p0z = if( corner == 0, z + randXYZ(z, y, x ) * r,  z + z_off + randXYZ(z, y, x ) * r);
	p0y = if( corner == 0, y + randXYZ(z, x, y ) * r,  y + y_off + randXYZ(z, x, y ) * r);
	#plus one on z axiz
	p1x = if( corner == 0, x + randXYZ(x, y, z + 1 ) * r,  x + x_off + randXYZ(x, y, z + 1 ) * r);
	p1z = if( corner == 0, z + 1 + randXYZ(z + 1, y, x ) * r,  z + 1 + z_off + randXYZ(z + 1, y, x ) * r);
	p1y = if( corner == 0, y + randXYZ(z + 1, x, y ) * r,  y + y_off + randXYZ(z, x, y ) * r);
	#plus one on x axis
	p2x = if( corner == 0, x + 1 + randXYZ(x + 1, y, z ) * r,  x + x_off + randXYZ(x, y, z - 1 ) * r);
	p2z = if( corner == 0, z + randXYZ(z, y, x + 1 ) * r,  z - 1 + z_off + randXYZ(z - 1, y, x ) * r);
	p2y = if( corner == 0, y + randXYZ(z, x + 1, y ) * r,  y + y_off + randXYZ(z, x, y ) * r);
	#plus one on both axis
	p3x = if( corner == 0, x + 1 + randXYZ(x + 1, y, z + 1 ) * r,  x - 1 + x_off + randXYZ(x - 1, y, z ) * r);
	p3z = if( corner == 0, z + 1 + randXYZ(z + 1, y, x + 1 ) * r,  z + z_off + randXYZ(z, y, x - 1 ) * r);
	p3y = if( corner == 0, y + randXYZ(z + 1, x + 1, y ) * r,  y + y_off + randXYZ(z, x, y ) * r);
	
	#next y level
	#bottom corner - center
	p4x = if( corner == 0, x + randXYZ(x, y + 1, z ) * r,  x + 1 + x_off + randXYZ(x + 1, y, z ) * r);
	p4z = if( corner == 0, z + randXYZ(z, y + 1, x ) * r,  z + z_off + randXYZ(z, y, x + 1 ) * r);
	p4y = if( corner == 0, y  + 1 + randXYZ(z, x, y + 1) * r,  y + y_off + randXYZ(z, x, y ) * r);
	#plus one on z axiz
	p5x = if( corner == 0, x + randXYZ(x, y + 1, z + 1 ) * r,  x + x_off + randXYZ(x, y - 1, z ) * r);
	p5z = if( corner == 0, z + 1 + randXYZ(z + 1, y + 1, x ) * r,  z + z_off + randXYZ(z, y - 1, x ) * r);
	p5y = if( corner == 0, y + 1 + randXYZ(z + 1, x, y + 1 ) * r,  y - 1 + y_off + randXYZ(z, x, y - 1 ) * r);
	#plus one on x axis
	p6x = if( corner == 0, x + 1 + randXYZ(x + 1, y + 1, z ) * r,  x + x_off + randXYZ(x, y + 1, z ) * r);
	p6z = if( corner == 0, z + randXYZ(z, y + 1, x + 1 ) * r,  z + z_off + randXYZ(z, y + 1, x ) * r);
	p6y = if( corner == 0, y + 1 + randXYZ(z, x + 1, y + 1 ) * r,  y + 1 + y_off + randXYZ(z, x, y + 1 ) * r);
	#plus one on both axis
	p7x = if( corner == 0, x + 1 + randXYZ(x + 1, y + 1, z + 1 ) * r,  20);
	p7z = if( corner == 0, z + 1 + randXYZ(z + 1, y + 1, x + 1 ) * r,  20);
	p7y = if( corner == 0, y + 1 + randXYZ(z + 1, x + 1, y + 1 ) * r,  20);
	
	
	
	#Euclidean distance w/o the root
	a =  abs( u - p1x ) ** 2 + abs( v - p1z ) ** 2 + abs( w - p1y ) ** 2;
	b =  abs( u - p2x ) ** 2 + abs( v - p2z ) ** 2 + abs( w - p2y ) ** 2;
	c =  abs( u - p3x ) ** 2 + abs( v - p3z ) ** 2 + abs( w - p3y ) ** 2;
	d =  abs( u - p4x ) ** 2 + abs( v - p4z ) ** 2 + abs( w - p4y ) ** 2;
	e =  abs( u - p5x ) ** 2 + abs( v - p5z ) ** 2 + abs( w - p5y ) ** 2;
	f =  abs( u - p6x ) ** 2 + abs( v - p6z ) ** 2 + abs( w - p6y ) ** 2;
	g =  abs( u - p7x ) ** 2 + abs( v - p7z ) ** 2 + abs( w - p7y ) ** 2;
	h =  20000; #abs( u - p8x ) ** 2 + abs( v - p8z ) ** 2;
	i =  abs( u - p0x ) ** 2 + abs( v - p0z ) ** 2 + abs( w - p0y ) ** 2;
	
	if(
		compare8(i, a, b, c, d, e, f, g, h ), randXYZ(p0x, p0y, p0z),
		compare8(a, i, b, c, d, e, f, g, h ), randXYZ(p1x, p1y, p1z),
		compare8(b, a, i, c, d, e, f, g, h ), randXYZ(p2x, p2y, p2z),
		compare8(c, a, b, i, d, e, f, g, h ), randXYZ(p3x, p3y, p3z),
		compare8(d, a, b, c, i, e, f, g, h ), randXYZ(p4x, p4y, p4z),
		compare8(e, a, b, c, d, i, f, g, h ), randXYZ(p5x, p5y, p5z),
		compare8(f, a, b, c, d, e, i, g, h ), randXYZ(p6x, p6y, p6z),
		compare8(g, a, b, c, d, e, f, i, h ), randXYZ(p7x, p7y, p7z),			
		0
	)

);
#~~
#~~
#### Voronoi Helper Functions	
#~
compare8(test, _1, _2, _3, _4, _5, _6, _7, _8 ) = (
	test <= _1 &&
	test <= _2 &&
	test <= _3 &&
	test <= _4 &&
	test <= _5 &&
	test <= _6 &&
	test <= _7 &&
	test <= _8 
);
	
compare7(test, _1, _2, _3, _4, _5, _6, _7 ) = (
	test <= _1 &&
	test <= _2 &&
	test <= _3 &&
	test <= _4 &&
	test <= _5 &&
	test <= _6 &&
	test <= _7 
);
compare6(test, _1, _2, _3, _4, _5, _6 ) = (
	test <= _1 &&
	test <= _2 &&
	test <= _3 &&
	test <= _4 &&
	test <= _5 &&
	test <= _6 
);
smallestOf8( _1, _2, _3, _4, _5, _6, _7, _8 ) = (
			if(
				compare7( _1, _2, _3, _4, _5, _6, _7, _8 ), _1,
				compare7( _2, _1, _3, _4, _5, _6, _7, _8 ), _2,
				compare7( _3, _2, _1, _4, _5, _6, _7, _8 ), _3,
				compare7( _4, _2, _3, _1, _5, _6, _7, _8 ), _4,
				compare7( _5, _2, _3, _4, _1, _6, _7, _8 ), _5,
				compare7( _6, _2, _3, _4, _5, _1, _7, _8 ), _6,
				compare7( _7, _2, _3, _4, _5, _6, _1, _8 ), _7,
				compare7( _8, _2, _3, _4, _5, _6, _7, _1 ), _8,
				0
				)
);
smallestOf7( _1, _2, _3, _4, _5, _6, _7 ) = (
			if(
				compare6( _1, _2, _3, _4, _5, _6, _7 ), _1,
				compare6( _2, _1, _3, _4, _5, _6, _7 ), _2,
				compare6( _3, _2, _1, _4, _5, _6, _7 ), _3,
				compare6( _4, _2, _3, _1, _5, _6, _7 ), _4,
				compare6( _5, _2, _3, _4, _1, _6, _7 ), _5,
				compare6( _6, _2, _3, _4, _5, _1, _7 ), _6,
				compare6( _7, _2, _3, _4, _5, _6, _1 ), _7,
				0
				)
);

smallest2Of8( _1, _2, _3, _4, _5, _6, _7, _8, w1, w2 ) = (
			if(
				compare7( _1, _2, _3, _4, _5, _6, _7, _8 ), _1 * w1 + if( w2 != 0, smallestOf7(_2, _3, _4, _5, _6, _7, _8) * w2, 0),
				compare7( _2, _1, _3, _4, _5, _6, _7, _8 ), _2 * w1 + if( w2 != 0, smallestOf7(_1, _3, _4, _5, _6, _7, _8) * w2, 0),
				compare7( _3, _2, _1, _4, _5, _6, _7, _8 ), _3 * w1 + if( w2 != 0, smallestOf7(_1, _2, _4, _5, _6, _7, _8) * w2, 0),
				compare7( _4, _2, _3, _1, _5, _6, _7, _8 ), _4 * w1 + if( w2 != 0, smallestOf7(_1, _2, _3, _5, _6, _7, _8) * w2, 0),
				compare7( _5, _2, _3, _4, _1, _6, _7, _8 ), _5 * w1 + if( w2 != 0, smallestOf7(_1, _2, _3, _4, _6, _7, _8) * w2, 0),
				compare7( _6, _2, _3, _4, _5, _1, _7, _8 ), _6 * w1 + if( w2 != 0, smallestOf7(_1, _2, _3, _4, _5, _7, _8) * w2, 0),
				compare7( _7, _2, _3, _4, _5, _6, _1, _8 ), _7 * w1 + if( w2 != 0, smallestOf7(_1, _2, _3, _4, _5, _6, _8) * w2, 0),
				compare7( _8, _2, _3, _4, _5, _6, _7, _1 ), _8 * w1 + if( w2 != 0, smallestOf7(_1, _2, _3, _4, _5, _6, _7) * w2, 0),
				0
				)
);

RandSmallest2Of8( _1, _2, _3, _4, _5, _6, _7, _8 ) = (
			if(
				compare7( _1, _2, _3, _4, _5, _6, _7, _8 ), randXZ( _1, smallestOf7(_2, _3, _4, _5, _6, _7, _8) ),
				compare7( _2, _1, _3, _4, _5, _6, _7, _8 ), randXZ( _2, smallestOf7(_1, _3, _4, _5, _6, _7, _8) ),
				compare7( _3, _2, _1, _4, _5, _6, _7, _8 ), randXZ( _3, smallestOf7(_1, _2, _4, _5, _6, _7, _8) ),
				compare7( _4, _2, _3, _1, _5, _6, _7, _8 ), randXZ( _4, smallestOf7(_1, _2, _3, _5, _6, _7, _8) ),
				compare7( _5, _2, _3, _4, _1, _6, _7, _8 ), randXZ( _5, smallestOf7(_1, _2, _3, _4, _6, _7, _8) ),
				compare7( _6, _2, _3, _4, _5, _1, _7, _8 ), randXZ( _6, smallestOf7(_1, _2, _3, _4, _5, _7, _8) ),
				compare7( _7, _2, _3, _4, _5, _6, _1, _8 ), randXZ( _7, smallestOf7(_1, _2, _3, _4, _5, _6, _8) ),
				compare7( _8, _2, _3, _4, _5, _6, _7, _1 ), randXZ( _8, smallestOf7(_1, _2, _3, _4, _5, _6, _7) ),
				0
				)
);



_smallest2Of8( _1, _2, _3, _4, _5, _6, _7, _8, w1, w2, _0, w0, func, param, x,z ) = (
			if(
				compare7( _1, _2, _3, _4, _5, _6, _7, _8 ), func( x,z, param, _0, w0, _1, w1, smallestOf7(_2, _3, _4, _5, _6, _7, _8), w2),
				compare7( _2, _1, _3, _4, _5, _6, _7, _8 ), func( x,z, param, _0, w0, _2, w1, smallestOf7(_1, _3, _4, _5, _6, _7, _8), w2),
				compare7( _3, _2, _1, _4, _5, _6, _7, _8 ), func( x,z, param, _0, w0, _3, w1, smallestOf7(_1, _2, _4, _5, _6, _7, _8), w2),
				compare7( _4, _2, _3, _1, _5, _6, _7, _8 ), func( x,z, param, _0, w0, _4, w1, smallestOf7(_1, _2, _3, _5, _6, _7, _8), w2),
				compare7( _5, _2, _3, _4, _1, _6, _7, _8 ), func( x,z, param, _0, w0, _5, w1, smallestOf7(_1, _2, _3, _4, _6, _7, _8), w2),
				compare7( _6, _2, _3, _4, _5, _1, _7, _8 ), func( x,z, param, _0, w0, _6, w1, smallestOf7(_1, _2, _3, _4, _5, _7, _8), w2),
				compare7( _7, _2, _3, _4, _5, _6, _1, _8 ), func( x,z, param, _0, w0, _7, w1, smallestOf7(_1, _2, _3, _4, _5, _6, _8), w2),
				compare7( _8, _2, _3, _4, _5, _6, _7, _1 ), func( x,z, param, _0, w0, _8, w1, smallestOf7(_1, _2, _3, _4, _5, _6, _7), w2),
				0
				)
);
#~~
#~~
#~~
###########################################################################################################################################				
# Togos Supplied Functions
###########################################################################################################################################				
#~
#### Handy functions ####

min(a,b) = if(a < b, a, b);
max(a,b) = if(a > b, a, b);

ridge( min, max, v ) = (
	diff = max - min;
	u = (v - min);
	w = u % (2 * (max - min));
	if( diff == 0, min,
		w < diff, min + w,
		max + diff - w 
	)
);

fractal( iterations, input-scale, output-scale, input-scale-factor, output-scale-factor, dy, basis, x,y,z ) =
	#(x,y,z) -> if(
	if(
		iterations == 0, 0,
		output-scale * basis(
			x / input-scale,
			y / input-scale,
			z / input-scale
		) + fractal(
			iterations - 1,
			input-scale * input-scale-factor,
			output-scale * output-scale-factor,
			input-scale-factor, output-scale-factor,
			dy, basis, x, y + dy, z )
	);
#~~			
###########################################################################################################################################	
# Material and Biome Constants
###########################################################################################################################################	
#~
materials.none    = -1;
air     		= material(0x00);
stone   		= material(0x01);
grass   		= material(0x02);
dirt    		= material(0x03);
cobblestone 	= material(4);
bedrock 		= material(0x07);
water   		= material(0x09);
lava    		= material(0x0B);
sand    		= material(0x0C);
gravel  		= material(0x0D); 
coal_o  		= material(16);
iron_o 	 		= material(15);
gold_o  		= material(14);
redstone_o 		= material(73);
diamond_o 		= material(56);
lapis_o			= 21;
sandstone		= 24;
mossycobble		= 48;
brick			= 45;
obsidian 		= 49;
ice 			= 79;
snow			= 80;
clay 			= 82;
netherrack		= 87;
soulsand		= 88;
glowstone		= 89;
stonebricks		= 98;
mycelium		= 110;
netherbrick		= 112;
endstone		= 121;
emerald_o		= 129;
netherquartz	= 153;
hardclay		= 172;
whiteclay		= material( 159, 0);
orangeclay		= material( 159, 1);
magentaclay		= material( 159, 2);
ltblueclay		= material( 159, 3);
yellowclay		= material( 159, 4);
limeclay		= material( 159, 5);
pinkclay		= material( 159, 6);
grayclay		= material( 159, 7);
ltgrayclay		= material( 159, 8);
cyanclay		= material( 159, 9);
purpleclay		= material( 159, 10);
blueclay		= material( 159, 11);
brownclay		= material( 159, 12);
greenclay		= material( 159, 13);
redclay			= material( 159, 14);
blackclay		= material( 159, 15);


siltstone		= material( 159, 0);
dolomite		= material( 159, 1);
gneiss		= material( 159, 2);
marble		= material( 159, 3);
shale		= material( 159, 4);
limestone		= material( 159, 5);
basalt		= material( 159, 6);
phyllite		= material( 159, 7);
slate		= material( 159, 8);
diorite		= material( 159, 9);
andesite		= material( 159, 10);
rhyolite		= material( 159, 11);
quartzite		= material( 159, 12);
schist		= material( 159, 13);
granite			= material( 159, 14);
gabbaro		= material( 159, 15);


#Plants
#Saplings ready to grow
oak = material( 6, 12 + 0);
pine = material( 6, 12 + 1);
birch = material( 6, 12 + 2);
jungle = material( 6, 12 + 3);
fern = material( 31, 2);
deadshrub = 32;
cacti = 81;
reed = 83;
pumpkin = 86;
melon = 103;
bean = 127;
#Biome Constants
#~
OCEAN = 0;
PLAINS = 1;
DESERT = 2;
E_HILL = 3;
FOREST = 4;
TAGIA = 5;
SWAMP = 6;
RIVER = 7;
FRZN_OCEAN = 10;
FRZN_RIVER = 11;
ICE_PLAIN = 12;
ICE_MNT = 13;
SHROOM = 14;
SHROOM_SHORE = 15;
BEACH = 16;
E_HILL_EDGE = 20;
JUNGLE = 21;
#~~
#~~
############################################################################################################################################
# Steppe landform -very versitile
############################################################################################################################################
#~
#Base height
# sets limit on height of base terrain, when noise generates large values lowering this will create more ridges
## Continental base
## 32 is good for small rolling hills... like normal minecraft
## 64 is well in between
## 128 is good for steppes
# scale of noise, a bigger value generates smoother continents, a small scale with a low height should make lots of ridges


#Notes on use of mountians
# Mountains are continent multiplied by scale.
#	-- slope of continent directly affects mountain slopes, the faster cont. changes the steeper And narrower the mountains
#	-- mountscale gives multiplier for cont. slope, a muliplier of two gives twice the slope
#	-- Max height of mount will be (CONTINENTHEIGHT - mountbase) * scale so (32-12) * 6 -> 120 added to base so 40 + 120 = 160
 
mountbase = 10; 				# at what height do mountians start
mountscale = 2;		# continent noise is muliplied by this 
#Using for foothills
mountbase_low = 8; # at what height do foothills start
mountscale_low = 1.5;
#Using for rockies
mountbase_sharp = 14; #29.25; # at what height do rockies start
mountscale_sharp = 3.5; #2 was orginal

##An attempt at removing the flat ridgelines normaly generated
##May need to be adjusted when change continent scale
bump(x,y,z) = fractal(1,32,8,1,1,1,simplex,x,y,z) * -1;

mountians(x,z, s, h, seed) = (
	mountbase + (((continent(x,z, s, h, seed) - mountbase) * mountscale ))  - 3
);

mountians_low(x,z, s, h, seed) = (
	mountbase_low + ((continent(x,z, s, h, seed) - mountbase_low) * mountscale_low)  - 3
);

mountians_sharp(x,z, s, h, seed) = (
	bump(x,seed,z) + (mountbase_sharp + ((continent(x,z, s, h, seed) - mountbase_sharp) * mountscale_sharp))
);

continent(x,z, scale, height, seed) = ridge(0, height, fractal(3,scale,16,25,8,0,simplex,x,seed,z) );
steppe( x,z, base, s1, h1, seed) =  
						if(
						(continent(x,z, s1, h1, seed) > mountians(x,z, s1, h1, seed)) && (continent(x,z, s1, h1, seed) > mountians_low(x,z, s1, h1, seed)) && (continent(x,z, s1, h1, seed) > mountians_sharp(x,z, s1, h1, seed)),
						base + continent(x,z, s1, h1, seed),
						(mountians(x,z, s1, h1, seed) > continent(x,z, s1, h1, seed)) && (mountians(x,z, s1, h1, seed) > mountians_low(x,z, s1, h1, seed)) && (mountians(x,z, s1, h1, seed) > mountians_sharp(x,z, s1, h1, seed)),
						base + mountians(x,z, s1, h1, seed),
						(mountians_low(x,z, s1, h1, seed) > continent(x,z, s1, h1, seed)) && (mountians_low(x,z, s1, h1, seed) > mountians(x,z, s1, h1, seed)) && (mountians_low(x,z, s1, h1, seed) > mountians_sharp(x,z, s1, h1, seed)),
						base + mountians_low(x,z, s1, h1, seed),
						(mountians_sharp(x,z, s1, h1, seed) > continent(x,z, s1, h1, seed)) && (mountians_sharp(x,z, s1, h1, seed) > mountians(x,z, s1, h1, seed)) && (mountians_sharp(x,z, s1, h1, seed) > mountians_low(x,z, s1, h1, seed)),
						base + mountians_sharp(x,z, s1, h1, seed),
						0) ;

#~~
############################################################################################################################################
# Ores
############################################################################################################################################
#~
#selects between ore1 to ore5 based on the output of a voronoiRand function
#Can use mulitple instances of the same ore for coarse control of rarity
#Slow because 3D
select_ore ( x,z, deposit_scale, randomness, ore1, ore2, ore3, ore4, ore4, ore5 ) = (
	#Not sure if the modulous operation is neccessary
	deposit = floor((voronoiRand( x,z, deposit_scale, randomness ) * 5) % 5);
	if(
		deposit == 0, ore1,
		deposit == 1, ore2,
		deposit == 2, ore3,
		deposit == 3, ore4,
		deposit == 4, ore5,
		0
	)
);

#Deposit width contols horizontal thickness, needs really small numbers, like 0.005
#Thickness controls vertical depth of deposits, needs to be large like 32
veinBottom( x,z, median_altitude, altitude_scale, altitude_range, deposit_scale, deposit_randomness, deposit_width, frequency_scale, thickness, seeda, seedb) = (
	median_altitude + simplex( x / altitude_scale, seeda, z / altitude_scale) * altitude_range + ((voronoiCell( x, z, deposit_scale, deposit_randomness, deposit_width, -1, 1, 0) + voronoiCell( x, z, deposit_scale / 4, deposit_randomness, deposit_width, -1, 1, 0)) / 2 - simplex(x / frequency_scale,seedb,z / frequency_scale)) * thickness
);
veinTop( x,z, median_altitude, altitude_scale, altitude_range, deposit_scale, deposit_randomness, deposit_width, frequency_scale, thickness, seeda, seedb) = (
	median_altitude + simplex( x / altitude_scale, seeda, z / altitude_scale) * altitude_range + ((voronoiCell( x, z, deposit_scale, deposit_randomness, deposit_width, -1, 1, 0) + voronoiCell( x, z, deposit_scale / 4, deposit_randomness, deposit_width, -1, 1, 0)) / 2 - simplex(x / frequency_scale,seedb - 1,z / frequency_scale)) * (thickness * -1)
);

#### #Best Ore generation system so far
#Works very well, blindingly fast. 
#Ores are generated on the surface of a large simplex funtion
#Desnities of a beta 1.7.3 world (the only large empty map on hand for testing) per square block
# coal 0.61		iron 0.31	redstone 0.11	gold 0.03	diamond	0.01

# In tests yeilded 0.03 blocks per sq block, uses voronoiCells. Angular, lattice like structure
landform_rare_ore(ore, altitude, seed, seeda, seedb, is_landform, layerlimit, thickness) = layer(
	ore,
	(x,z) -> if( is_landform(x,z),
				if( layerlimit(x,z) > veinBottom( x + seed,z, altitude, 256, 32, 64, 0.5, 0.005, 128, 16, seeda, seedb ),
					veinBottom( x + seed,z, altitude, 256, 32, 64, 0.5, 0.005, 128, 16, seeda, seedb ) - thickness,
					-1
					),
				-1
				),
	(x,z) -> if( is_landform(x,z),
				if( layerlimit(x,z) > veinTop( x + seed,z, altitude, 256, 32, 64, 0.5, 0.005, 128, 16, seeda, seedb ),
					veinTop( x + seed,z, altitude, 256, 32, 64, 0.5, 0.005, 128, 16, seeda, seedb ),
					layerlimit(x,z)
					),
				-1
				)
	
);
rare_ore(ore, altitude, seed, seeda, seedb, layerlimit, thickness) = layer(
	ore,
	(x,z) -> if( layerlimit(x,z) > veinBottom( x + seed,z, altitude, 256, 32, 64, 0.5, 0.005, 128, 16, seeda, seedb ),
					veinBottom( x + seed,z, altitude, 256, 32, 64, 0.5, 0.005, 128, 16, seeda, seedb ) - thickness,
					-1
					),
	(x,z) -> if( layerlimit(x,z) > veinTop( x + seed,z, altitude, 256, 32, 64, 0.5, 0.005, 128, 16, seeda, seedb ),
					veinTop( x + seed,z, altitude, 256, 32, 64, 0.5, 0.005, 128, 16, seeda, seedb ),
					layerlimit(x,z)
					)
	
);

# In tests with density 6 yeilded 0.15 blocks per sq block, uses simplex. Ropey structure like rivers only broken up
# In practice much lower densities exist because of landform limitations
# Lower densities inc amount of ore
# Uses a two arg function for altitude
# An example would be (x,z) -> 120 + simplexS(x, 342,z, 128) * 64
# If a flat distribution is desired use: (x,z) -> (43)
# alt, is_landform, & layer_limit are all two argument functions
simplex_ore(ore, alt, s1, s2, s3, is_landform, layer_limit, density) = layer(
	ore,
	(x,z) -> if( is_landform(x,z),
					if( steppe(x,z, alt(x,z), 16, density, s1) - 1 < alt(x,z),
						#if( layer_limit(x,z) > steppe(x,z, alt(x,z), 16, density, s1) - simplexS(x,s2,z,32) * 16,
								steppe(x,z, alt(x,z), 16, density, s1) - simplexS(x,s2,z,32) * 16, 
								#-1),
						-1),
				-1),
	(x,z) -> if( is_landform(x,z),
				if( steppe(x,z, alt(x,z), 16, density, s1) - 1 < alt(x,z), 
					if( layer_limit(x,z) > steppe(x,z, alt(x,z), 16, density, s1) + simplexS(x,s3,z,32) * 16, 
							steppe(x,z, alt(x,z), 16, density, s1) + simplexS(x,s3,z,32) * 16, 
							layer_limit(x,z)
							),
					-1), 
				-1)
);
simplex_oreB(ore, alt, s1, s2, s3, layer_limitB, layer_limit, density) = layer(
	ore,
	(x,z) -> if( steppe(x,z, alt(x,z), 16, density, s1) - 1 < alt(x,z),
						if( layer_limitB(x,z) < steppe(x,z, alt(x,z), 16, density, s1) - simplexS(x,s2,z,32) * 16,
								steppe(x,z, alt(x,z), 16, density, s1) - simplexS(x,s2,z,32) * 16, 
								layer_limitB(x,z)),
						-1),
	(x,z) -> if( steppe(x,z, alt(x,z), 16, density, s1) - 1 < alt(x,z), 
					if( layer_limit(x,z) > steppe(x,z, alt(x,z), 16, density, s1) + simplexS(x,s3,z,32) * 16, 
							steppe(x,z, alt(x,z), 16, density, s1) + simplexS(x,s3,z,32) * 16, 
							layer_limit(x,z)
							),
					-1)
);
#Good values are frequency <= 4; thickness = 0.85; height_variance total variance
#Places ore above base_alt value in a range upto height variance
#Per region
#2 == appx. 0-2 
#3 == appx. 4-6
#4 == appx. 10-14
#8 == appx. 30%
#10 == appx. 50%
#new_simplex_ore( ore, min_alt, max_alt, frequency, thickness, height_variance, variance_scale, seeda, seedb, seedc )
new_simplex_ore( ore, basealtitude_f, maxaltitude_f, frequency, thickness, height_variance, variance_scale, seeda, seedb, seedc, seedd ) = layer(
	ore,
	(x,z) -> basealtitude_f(x,z) + abs(perlinS(x,seeda,z,variance_scale) * (height_variance)),
	(x,z) -> if ( (voronoiTiles( x,z + seedd, 32, 0.7, 10 ) > (10 - frequency) ) && (ridge(0, 1, abs(simplexS(x,seedc,z, 32)) * 8) > thickness), 
					if( basealtitude_f(x,z) + (abs(perlinS(x,seedb,z, variance_scale)) ) * height_variance > maxaltitude_f(x,z),
						maxaltitude_f(x,z),
						basealtitude_f(x,z) + (abs(perlinS(x,seedb,z, variance_scale)) ) * height_variance), 
					0)
);

#Another awesome pattern, holes punched in paper
#(x,z) -> 10 + if( voronoiCell( x, z, 32, 0.70, 0.05, 1, 1, 0) * 16  >= 15.125, 120, -1)

#~~
############################################################################################################################################
# Biomes
############################################################################################################################################
#~


#Noise functions for climate
#Tried to sync with xstart and zstart w/o success
biome_scale = 256;
temp(x,z) = midpoint(2, 32, 0.1, 0.5, 0.5, 1, z, x ) *  2 +  ridge( 0, 1, abs( 512 + z - x) % 8000 / 4000);
rain(x,z) = (midpoint( 3, biome_scale , 1, 0.5, 0.5, 1, z, x ) * 1) / 1.75;
#Replace with surface geology???
drain(x,z) =  midpoint( 3, biome_scale, 1, 1, 0.75, 0.25, x - 12947561, z - 12348561) / 1.75;
#Altitude adjustment equations
alt_temp(x,z) = complex_cont(x,z) / 250 + if(is_valley(x,z), 0.05, 0) - if(is_steppe(x,z), 0.1, 0);

alt_drain(x,z) =  complex_cont(x,z) / 128 + if(is_steppe(x,z), -0.025, 0);

#Real sensitive, can require some really small values
#Temperature thresholds
hot = -0.35;
cold = -.92;
#Rainfall thresholds
wet = 0.3;
arid = 0.175;
#Drainage thresholds
lowdrain = 0.45;
highdrain = 0.85;

select_biome(x,z) = 
#~
if( 
						#Ocean, and by extension all floating isles above ocean
						#complex_cont(x,z) < 50 && is_valley(x,z), E_HILL,
						#Was causeing problems with millenaire
						#is_valley(x,z) && complex_cont(x,z) <= valley_beach && complex_cont(x,z) > 50, RIVER,
						is_valley(x,z) && complex_cont(x,z) < valley_river, OCEAN,
						is_hills(x,z) && complex_cont(x,z) <= hills_beach, RIVER,
						is_steppe(x,z) && complex_cont(x,z) <= steppe_beach, RIVER,


						drain(x,z) + alt_drain(x,z) < lowdrain,
						if( temp(x,z) - alt_temp(x,z) < cold,
								if(
									rain(x,z) < arid, ICE_PLAIN,
									rain(x,z) > wet, TAGIA,
									TAGIA #moderate rain
								),
							temp(x,z) - alt_temp(x,z) > hot,
								if(
									rain(x,z) < arid, PLAINS,
									rain(x,z) > wet, SWAMP,
									FOREST #moderate rain
								),
							#temperate temperature
							if(
									rain(x,z) < arid, PLAINS,
									rain(x,z) > wet, FOREST,
									FOREST #moderate rain
								)
						),
						drain(x,z) + alt_drain(x,z) > highdrain,
						if( 
							temp(x,z) - alt_temp(x,z) < cold,
								if(
									rain(x,z) < arid, ICE_PLAIN,
									rain(x,z) > wet, ICE_PLAIN,
									ICE_PLAIN #moderate rain
								)
							,
							temp(x,z) - alt_temp(x,z) > hot,
								if(
									rain(x,z) < arid, DESERT,
									rain(x,z) > wet, PLAINS,
									JUNGLE #moderate rain
								)
							,
							#temperate temperature
							if(
									rain(x,z) < arid, PLAINS,
									rain(x,z) > wet, FOREST,
									PLAINS #moderate rain
								)
						),
						#moderate drainage
						if( 
							temp(x,z) - alt_temp(x,z) < cold,
								if(
									rain(x,z) < arid, ICE_PLAIN,
									rain(x,z) > wet, TAGIA,
									TAGIA #moderate rain
								)
							,
							temp(x,z) - alt_temp(x,z) > hot,
								if(
									rain(x,z) < arid, DESERT,
									rain(x,z) > wet, JUNGLE,
									PLAINS #moderate rain
								)
							,
							#temperate temperature
							if(
									rain(x,z) < arid, PLAINS,
									rain(x,z) > wet, FOREST,
									FOREST #moderate rain
								)
						)
						
					);
#~~					
select_biome_test(x,z) = 
#~
if( 
						drain(x,z) + alt_drain(x,z) < lowdrain,
						if( temp(x,z) - alt_temp(x,z) < cold,
								if(
									rain(x,z) < arid, snow,
									rain(x,z) > wet, ice,
									ice #moderate rain
								),
							temp(x,z) - alt_temp(x,z) > hot,
								if(
									rain(x,z) < arid, grass,
									rain(x,z) > wet, obsidian,
									dirt #moderate rain
								),
							#temperate temperature
							if(
									rain(x,z) < arid, grass,
									rain(x,z) > wet, dirt,
									dirt #moderate rain
								)
						),
						drain(x,z) + alt_drain(x,z) > highdrain,
						if( 
							temp(x,z) - alt_temp(x,z) < cold,
								if(
									rain(x,z) < arid, snow,
									rain(x,z) > wet, snow,
									snow #moderate rain
								)
							,
							temp(x,z) - alt_temp(x,z) > hot,
								if(
									rain(x,z) < arid, sand,
									rain(x,z) > wet, grass,
									lava #moderate rain
								)
							,
							#temperate temperature
							if(
									rain(x,z) < arid, grass,
									rain(x,z) > wet, dirt,
									grass #moderate rain
								)
						),
						#moderate drainage
						if( 
							temp(x,z) - alt_temp(x,z) < cold,
								if(
									rain(x,z) < arid, snow,
									rain(x,z) > wet, ice,
									ice #moderate rain
								)
							,
							temp(x,z) - alt_temp(x,z) > hot,
								if(
									rain(x,z) < arid, sand,
									rain(x,z) > wet, lava,
									grass #moderate rain
								)
							,
							#temperate temperature
							if(
									rain(x,z) < arid, grass,
									rain(x,z) > wet, dirt,
									dirt #moderate rain
								)
						)
						
					);
#~~
#~~
############################################################################################################################################
# Volcanics
############################################################################################################################################
#~
volcano(_x,_z) = (
				x = _x + xstart;
				z = _z + zstart;
				pos(simplexS(x + perlinS(x, 3241, z, 64) * 32,546,z + perlinS(x, 1234, z, 64) * 32, 256)
				- midpoint(2, 512, 1, 0.5, 0.25, .5, x,z))  
				* 1024);
volcano_alt = 110;
lava_alt = 109;
lava_river(x,z) = steppe(x,z, 18, 8, 12, 125);
#~~
############################################################################################################################################
# Floating Isles --Only place above ocean b/c when over another landscape the surface won't get trees etc
############################################################################################################################################
#~
is_floating_isle(x,z) =  complex_cont(x,z) < 50 && is_valley(x,z);
floating_isle_river(x,z) = steppe(x,z, 180, 8, 12, 234);
floating_isle_roof(x,z) = if(
							(voronoiTiles( x + simplex( x, 32, z, 48) * 8,z + simplex( x, 32, z, 48) * 8, 64, 0.5, 6) + 0) > 2, 
							((voronoiCell(x,z, 64, 0.7, 0, 3, 0, 0) * 6)), -1);
floating_isle_floor(x,z) = if(
							(voronoiTiles( x + simplex( x, 32, z, 48) * 8,z + simplex( x, 32, z, 48) * 8, 64, 0.5, 6) + 0) > 2, 
							sin((voronoiCell(x,z, 16, 0.7, 0, 6, 0, 0) )) * 8, -1);
#~~
############################################################################################################################################
# Rivers
############################################################################################################################################
#~
#River and beach altitudes
valley_beach = 66;
valley_river = 65;
hills_beach = 81.2;
hills_river = 81;
steppe_beach = 41.5;
steppe_river = 41.25;

# Makes use of the awesome list functionality that Togos added.
#mask_func is passed x and z
complex_cont_river( river_mat, river_alt, beach_mat, beach_alt, beach_depth, mud_mat, mud_depth, mask_func) = list(
	#beach
	layer(
		beach_mat,
		(x,z) -> if( complex_cont(x,z) < beach_alt && mask_func(x,z), complex_cont(x,z) - beach_depth, -1),
		(x,z) -> if( complex_cont(x,z) < beach_alt && mask_func(x,z), complex_cont(x,z), -1)
	),
	
	#mud
	layer(
		mud_mat,
		(x,z) -> if( complex_cont(x,z) < river_alt && mask_func(x,z), complex_cont(x,z) - mud_depth, -1),
		(x,z) -> if( complex_cont(x,z) < river_alt && mask_func(x,z), complex_cont(x,z), -1)
	),
	#river
	layer(
		river_mat,
		(x,z) -> if( complex_cont(x,z) <= river_alt && mask_func(x,z), complex_cont(x,z), -1),
		(x,z) -> if( complex_cont(x,z) <= river_alt && mask_func(x,z), river_alt, -1)
	)
);
#river_func and mask_func are passed x and z
river( river_mat, river_alt, beach_mat, beach_alt, beach_depth, mud_mat, mud_depth, mask_func, river_func) = list(
	#beach
	layer(
		beach_mat,
		(x,z) -> if( river_func(x,z) < beach_alt && mask_func(x,z), river_func(x,z) - beach_depth, -1),
		(x,z) -> if( river_func(x,z) < beach_alt && mask_func(x,z), river_func(x,z), -1)
	),
	
	#mud
	layer(
		mud_mat,
		(x,z) -> if( river_func(x,z) < river_alt && mask_func(x,z), river_func(x,z) - mud_depth, -1),
		(x,z) -> if( river_func(x,z) < river_alt && mask_func(x,z), river_func(x,z), -1)
	),
	#river
	layer(
		river_mat,
		(x,z) -> if( river_func(x,z) < river_alt && mask_func(x,z), river_func(x,z), -1),
		(x,z) -> if( river_func(x,z) < river_alt && mask_func(x,z), river_alt, -1)
	)
);
#~~
############################################################################################################################################
# Caves
############################################################################################################################################
#~
#fractal( iterations, input-scale, output-scale, input-scale-factor, output-scale-factor, y-offset, basis )
deep_cave_roof(x,z) = fractal( 3, 128, 64, 0.5, 0.5, 3, simplex, x, 5687, z);
deep_cave_floor(x,z) = fractal( 3, 128, 64, 0.5, 0.5, 3, simplex, x, 31234, z);

living_cave( air_mat, ground_mat, ground_depth, pool_mat, pool_alt, lights_mat, light_density, roof_mat, roof_depth, altitude, floor_func, roof_func, mask_func) = list(
	layer(
		air_mat,
		(x,z) -> if( mask_func(x,z), altitude - floor_func(x,z), -1),
		(x,z) -> if( mask_func(x,z), altitude + roof_func(x,z), -1)
	),
	#Ground cover
	layer(
		ground_mat,
		(x,z) -> if( mask_func(x,z), altitude - floor_func(x,z) - ground_depth, -1),
		(x,z) -> if( mask_func(x,z) && (altitude - floor_func(x,z) < altitude + roof_func(x,z)), altitude - floor_func(x,z), -1)
	),
	#Pools
	layer(
		pool_mat,
		(x,z) -> if( mask_func(x,z) && altitude - floor_func(x,z) < pool_alt, altitude - floor_func(x,z), -1),
		(x,z) -> if( mask_func(x,z) && altitude - floor_func(x,z) < pool_alt, pool_alt, -1)
	),
	#Lights
	layer(
		lights_mat,
		(x,z) -> if( mask_func(x,z), altitude + roof_func(x,z) - light_density, -1),
		(x,z) -> if( mask_func(x,z) && (altitude - floor_func(x,z) < altitude + roof_func(x,z)), altitude + roof_func(x,z), -1)
	),
	#Roof
	layer(
		roof_mat,
		(x,z) -> if( mask_func(x,z), altitude + roof_func(x,z) - roof_depth, -1),
		(x,z) -> if( mask_func(x,z) && (altitude - floor_func(x,z) < altitude + roof_func(x,z)), altitude + roof_func(x,z) , -1)
	)
);

layeredrockU( mat1, d1, mat2, d2, mat3, d3, mat4, d4, base_func, max_func ) = list( 
	layer(mat1, (x,z) -> base_func(x,z), 				(x,z) -> if( base_func(x,z) + d1 > max_func(x,z),					max_func(x,z), base_func(x,z) + d1)),
	layer(mat2, (x,z) -> base_func(x,z) + d1, 			(x,z) ->  if( base_func(x,z) + d1 + d2 > max_func(x,z), 			max_func(x,z), base_func(x,z) + d1 + d2 )),
	layer(mat3, (x,z) -> base_func(x,z) + d1 + d2, 		(x,z) ->  if( base_func(x,z) + d1 + d2 + d3 > max_func(x,z), 		max_func(x,z), base_func(x,z) + d1 + d2 + d3 )),
	layer(mat4, (x,z) -> base_func(x,z) + d1 + d2 + d3, (x,z) ->  if( base_func(x,z) + d1 + d2 + d3 + d4 > max_func(x,z),	max_func(x,z), base_func(x,z) + d1 + d2 + d3 + d4))
);
layersUp( mat1, d1, mat2, d2, mat3, d3, mat4, d4, base_func, max_func ) = list( 
	layer(mat1, (x,z) -> base_func(x,z), 								(x,z) -> if( base_func(x,z) + d1(x,z) > max_func(x,z),					max_func(x,z), base_func(x,z) + d1(x,z))),
	layer(mat2, (x,z) -> base_func(x,z) + d1(x,z), 						(x,z) -> if( base_func(x,z) + d1(x,z) + d2(x,z) > max_func(x,z), 			max_func(x,z), base_func(x,z) + d1(x,z) + d2(x,z) )),
	layer(mat3, (x,z) -> base_func(x,z) + d1(x,z) + d2(x,z), 			(x,z) -> if( base_func(x,z) + d1(x,z) + d2(x,z) + d3(x,z) > max_func(x,z), 		max_func(x,z), base_func(x,z) + d1(x,z) + d2(x,z) + d3(x,z) )),
	layer(mat4, (x,z) -> base_func(x,z) + d1(x,z) + d2(x,z) + d3(x,z), 	(x,z) -> if( base_func(x,z) + d1(x,z) + d2(x,z) + d3(x,z) + d4(x,z) > max_func(x,z),	max_func(x,z), base_func(x,z) + d1(x,z) + d2(x,z) + d3(x,z) + d4(x,z)))
);
layeredrockD( mat1, d1, mat2, d2, mat3, d3, mat4, d4, base_func, min_func ) = list(
	layer(mat1, (x,z) -> base_func(x,z) - d1, 					(x,z) -> if( base_func(x,z) < min_func(x,z), 				min_func(x,z), base_func(x,z))),
	layer(mat2, (x,z) -> base_func(x,z) - d1 - d2, 				(x,z) -> if( base_func(x,z) - d1 < min_func(x,z), 			min_func(x,z), base_func(x,z) - d1)),
	layer(mat3, (x,z) -> base_func(x,z) - d1 - d2 - d3, 		(x,z) -> if( base_func(x,z) - d1 - d2 < min_func(x,z), 		min_func(x,z), base_func(x,z) - d1 - d2)),
	layer(mat4, (x,z) -> base_func(x,z) - d1 - d2 - d3 - d4,	(x,z) -> if( base_func(x,z) - d1 - d2 - d3 < min_func(x,z), min_func(x,z), base_func(x,z) - d1 - d2 - d3 ))
);

#Carefull is 3D ore so it will be slow
caves-3d(type, vertical_scale, horizontal_scale, width, min_func, max_func) = layer(
	(x,y,z) -> if ( abs(simplexS(x,y / vertical_scale,z, horizontal_scale)) < width, type, -1),
	(x,z) -> min_func(x,z),
	(x,z) -> max_func(x,z)
);
# Templates
# The voronoiCell works well for genereating a pattern in the layers
#### layersUp(whiteclay, (x,z) -> 9 + simplexS(x,132,z, 32) * 8, 
		#### magentaclay, (x,z) -> 7  + simplexS(x,678,z, 32) * 8, 
		#### grayclay, (x,z) -> 5 + simplexS(x,54,z, 32) * 8, 
		#### cyanclay, (x,z) -> 8 + simplexS(x,89,z, 32) * 8, 
		#### (x,z) -> voronoiCell(x,z, 64, 0.5, 0, 64, 0, 0) + 128 + (simplexS(x,89,z, 32) * 8) + simplexS(x,34,z, 32) * 8 + (simplexS(x,14,z, 64) * 32), complex_cont ),
#### #Similar to Minecraft's caves
#### layer(
	#### (x,y,z) -> if ( abs(simplexS(x,y / 16,z, 64) + simplexS(x,y / 16,z, 32) / 2) ** 2 < 0.0025, air, -1),
	#### (x,z) -> if ( voronoiTiles( x,z + 625, 32, 0.7, 10 ) > 5, 1, -1),
	#### (x,z) -> if ( voronoiTiles( x,z + 3245, 32, 0.7, 10 ) > 5, 255, 0 )
#### ),	
#~~

############################################################################################################################################
# Valley Landform
############################################################################################################################################
#~
#Scales for valley landform
s1 = 256;
s2 = 128;
s3 = 64;

#### voronoicont( x,z, multiplier1, multiplier2, multiplier3 ) = 
					#### voronoiCellM( x, z, s1, 0.50, 2, -8, -0.987, 0) * multiplier1 
					#### + voronoiCellM( x, z, s2, 0.50, 2, -8, 6.5, 0) * multiplier2
					#### + voronoiCellM( x, z, s3, 0.50, 2, -8, -0.987, 0)  * multiplier3;
voronoicont( x,z, multiplier1, multiplier2, multiplier3 ) = 
					voronoiCell( x, z, s1, 0.50, 2, -8, -0.987, 0) * multiplier1 
					+ voronoiCell( x, z, s2, 0.50, 2, -8, 6.5, 0) * multiplier2
					+ voronoiCell( x, z, s3, 0.50, 2, -8, -0.987, 0)  * multiplier3;

valley( x,z) = (
				60 + 
				voronoiCell( x + simplexS( x,32,z, 64) * 512,z + simplexS( z,32,x, 64) * 512, 1000, 0.75, 3, -25, -6, 0) * 2 + 
				if(voronoicont( x,z, 16, 4, 2 ) < 0,
					abs(voronoicont( x,z, 16, 4, 2 )) * 2,
					voronoicont( x,z, 32, 8, 4 ) / 3.5
				));
#~~
############################################################################################################################################
# Combined Landform & Geology
############################################################################################################################################				
#~

# Mask for hills and steppes
hills_r(x,z) = radius_e(x, z, 0, 3048, 1300, 950, 1000, 128, 256, 234);
steppe_r(x,z) = radius_e(x, z, 2024, 1024, 750, 900, 924, 128, 256, 269);

is_hills( _x,_z) =  if( hills_r(_x, _z) > 100, 1,  0) == 1;
isnot_hills( _x,_z) =  if( hills_r(_x, _z) <= 0, 1,  0) == 1;
mix_hills( _x,_z) =  if( hills_r(_x, _z) <= 100 && hills_r(_x, _z) > 0, hills_r(_x, _z),  0);
	
is_steppe( x,z) =  if( steppe_r(x,z) > 100, 1,  0) == 1;
isnot_steppe( x,z) = if( steppe_r(x,z) <= 0, 1,  0) == 1;
mix_steppe( x,z) =  if( steppe_r(x,z) <= 100 && steppe_r(x,z) > 0, steppe_r(x,z),  0);
is_mix_steppe( x,z) =  steppe_r(x,z) <= 5 && steppe_r(x,z) > 0;

	
is_valley(x,z) = (isnot_hills(x,z) || mix_hills(x,z) > 0) && (isnot_steppe(x,z) || mix_steppe(x,z) > 0);
is_valley_mount(x,z) = (isnot_hills(x,z) || mix_hills(x,z) > 0) && (isnot_steppe(x,z) || mix_steppe(x,z) > 0) && voronoicont( x,z, 16, 4, 2 ) < 0;
is_valley_ocean(x,z) = (isnot_hills(x,z) || mix_hills(x,z) > 0) && (isnot_steppe(x,z) || mix_steppe(x,z) > 0) && complex_cont(x,z) < valley_river;
#need a separate function for river so can eliminate water walls
is_valley_river(x,z) = (isnot_hills(x,z) || mix_hills(x,z) > 0) && (isnot_steppe(x,z));

mix(x, z, v, start, range, a, ax, az, b, bx, bz) = (a(ax,az) * ( range - (v - start)) / range) +  (b(bx,bz) *  ( v - start) / range);

steppes(x,z) = steppe(x,z, 40, 128, 24, 0);
hills(x,z) = steppe(x,z, 80, 32, 24, 0);
#### steppe_edge(x,z) = (100 - mix_steppe(x,z)) * .66;
#steppe_edge(x,z) = steppes(x,z) + pos(66 - steppes(x,z)) * ( 1 - mix_steppe(x,z) / 100);
#### steppe_edge(x,z) = if( mix_steppe(x,z) > 50,
						#### if( (1 - (mix_steppe(x,z) - 50) / 50) * 66 > steppes(x,z), (1 - (mix_steppe(x,z) - 50) / 50) * 66, valley(x,z) ),
					   #### mix_steppe(x,z) > 0,
						#### if( (mix_steppe(x,z) / 50) * 66 > valley(x,z), (mix_steppe(x,z) / 50) * 66, steppes(x,z)),
						#### valley(x,z)
					#### );

complex_cont(x,z) = (
						#Can be used for individually positioning landforms 
					x1 = x + 0 + xstart;
					z1 = z + 0 + zstart;
					x_steppe = x + 1200 + xstart;
					z_steppe = z + -300 + zstart;
					x_hills = x + 0 + xstart;
					z_hills = z + 0 + zstart;
					if(
						#Mix different landforms, artifacts are formed when rivers meet edges 
						#Really strange stuff happens when steppe and hllls intersect
						mix_steppe(x,z) > 0 && mix_hills(x,z) > 0, mix(x,z, mix_steppe(x,z), 0, 100, steppes, x_steppe,z_steppe, hills, x_hills,z_hills ),
						mix_hills(x,z) > 0 && mix_steppe(x,z) <= 0, mix(x,z, mix_hills(x,z), 0, 100, valley, x1, z1, hills, x_hills,z_hills ),
						mix_steppe(x,z) > 0 && mix_hills(x,z) <= 0, mix(x,z, mix_steppe(x,z), 0, 100, valley, x1, z1, steppes, x_steppe,z_steppe ),
						#### mix_steppe(x,z) > 0 && mix_hills(x,z) <= 0, mix(x,z, mix_steppe(x,z), 0, 100, valley, x1, z1, steppe_edge, x_steppe,z_steppe ),
						#mix_steppe(x,z) > 0 && mix_hills(x,z) <= 0, steppe_edge(x_steppe,z_steppe),
						
						#### mix_steppe(x,z) >= 50 && mix_hills(x,z) <= 0, mix(x,z, mix_steppe(x,z), 50, 100, (x,z) -> (66), x1, z1, steppe_edge, x_steppe,z_steppe ),
						#### mix_steppe(x,z) > 0 && mix_steppe(x,z) < 50 && mix_hills(x,z) <= 0, mix(x,z, mix_steppe(x,z), 0, 50, valley, x1, z1, (x,z) -> (66), x_steppe,z_steppe ),
						
						
						is_steppe(x,z), steppes( x_steppe,z_steppe ),
						is_hills(x,z), hills( x_hills,z_hills ),
					valley(x1,z1)
					));

geology_layer_a(x,z) = steppe( x,z, 30, 128, 24, 5768);
geology_layer_b(x,z) = steppe( x,z, 10, 128, 24, 165);
geology_layer_c(x,z) = steppe( x,z, 40, 128, 24, 5768);
geology_layer_d(x,z) = if(geology_layer_c(x,z) > complex_cont(x,z), complex_cont(x,z), geology_layer_c(x,z));
geology_layer_e(x,z) = if(geology_layer_b(x,z) > complex_cont(x,z), complex_cont(x,z), geology_layer_b(x,z));

contintent_limit(x,z) = complex_cont(x,z);
no_limit(x,z) = 256;
#true and false don't seem to work 
# 1 == 1 doesn't work really strange --- bug report
is_anywhere(x,z) = (x == x);

dirt_depth(x,z) = if( complex_cont(x,z) < 100, 3, 1);
#~~
#### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #
#Build this world
#### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #



test = layered-terrain (
	layer(
		grass,
		1,
		(x,z) -> if( z < 0 && x > 0, voronoiCell( x,z, 128, .7, 1, -1,0,0) * 100, 0 )
		),
	layer(
		dirt,
		1,
		(x,z) -> if( z > 0 && x > 0, voronoiCell( x,z, 128, .7, 1, 1,0,0) * 100, 0 )
		),
	layer(
		stone,
		1,
		(x,z) -> if( z < 0 && x < 0, voronoiCell( x,z, 128, .7, 0, 1,0,0) * 100, 0 )
		),
	layer(
		water,
		1,
		(x,z) -> if( z > 0 && x < 0, (voronoiCell( x,z, 128, .7, 0, 1,0,0) * 100) - (voronoiCell( x,z, 128, .7, 0, -1,0,0) * 5), 0 )
		),
	layer( 
		bedrock,
		0,
		1
		)
);
#### test
world